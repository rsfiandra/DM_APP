<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>N6 — Personal Notes & Tasks (Template)</title>
  <meta name="color-scheme" content="light"/>
  <style>
    :root{
      /* Palette (inspired by CFOE/TFI) */
      --bg:#f7f9fc; --ink:#0f172a; --muted:#64748b; --line:#e2e8f0;
      --brand1:#ff8a00; --brand2:#ff6a00; /* theme, changed via picker */
      --header-fill: linear-gradient(90deg, var(--brand1), var(--brand2));
      --head-tint: rgba(255, 138, 0, 0.12);
      --head-tint-border: rgba(255, 138, 0, 0.4);
      --finish-pill-bg: rgba(255,138,0,.16);
      --finish-pill-border: rgba(255,138,0,.4);
      --finish-pill-text:#b45309;
      /* SharePoint mobile canvas offsets */
      --sp-mobile-gutter:1px; --sp-left-offset:0px; --sp-right-offset:0px;
      /* Kanban */
      --kanban-col:#f8fafc; --kanban-drop:#eef2ff;
      /* Table */
      --thead-bg:#f2f4f8; --thead-text:#475569;
      --calendar-cell-min-width:120px;
      --calendar-cell-max-width:190px;
    }
    *,*::before,*::after{box-sizing:border-box}
    html,body{margin:0;padding:0;height:100%}
    body{font:14px system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--ink)}
    a{color:#2563eb;text-decoration:none}
    a:hover{text-decoration:underline}
    .wrap{
      width:100%;
      margin:0 auto;
      max-width:min(1400px, calc(100vw - 40px));
      padding:clamp(16px, 2.5vw, 28px);
    }
    body.table-full .wrap{
      max-width:none;
      width:100%;
      padding-left:clamp(16px, 2vw, 48px);
      padding-right:clamp(16px, 2vw, 48px);
    }
    body.table-full #view-table .card-body{
      padding:24px;
    }
    body.table-full #view-table .grid{
      overflow:auto;
    }

    /* --- Tab bar with status chips + gear --- */
    .tab-bar{position:sticky;top:0;z-index:50;display:flex;align-items:center;gap:8px;padding:calc(8px + env(safe-area-inset-top,0px)) 0 8px;background:var(--bg);border-bottom:1px solid var(--line);box-shadow:0 6px 12px rgba(15,23,42,.08)}
    .tab-buttons{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .tab-buttons button{border:1px solid var(--line);border-radius:12px;padding:6px 14px;background:#fff;font-weight:600;color:#334155;cursor:pointer}
    .tab-buttons button.active{background:var(--header-fill);color:#fff;border-color:transparent}
    .tab-select{display:none;padding:6px 32px 6px 10px;border:1px solid var(--line);border-radius:8px;background:#fff}
    #controlBtns{margin-left:auto;display:flex;align-items:center;gap:8px}
    .chip{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid var(--line);background:#fff;font-size:12px;font-weight:700;color:var(--muted)}
    .chip.ok{color:#166534;background:rgba(16,185,129,.14);border-color:rgba(22,163,74,.45)}
    .chip.warn{color:#92400e;background:rgba(252,211,77,.18);border-color:rgba(202,138,4,.45)}
    .gear{width:32px;height:32px;border:none;border-radius:8px;background:var(--header-fill);color:#fff;font-size:16px;display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 1px 2px rgba(15,23,42,.12)}
    .theme-picker{position:absolute;right:calc(8px + env(safe-area-inset-right,0px));top:54px;background:#fff;border:1px solid var(--line);border-radius:12px;box-shadow:0 4px 12px rgba(15,23,42,.1);padding:12px;min-width:170px;display:none;z-index:1000}
    .theme-picker h5{margin:0 0 8px;font-size:12px;color:var(--muted)}
    .swatches{display:flex;gap:8px;flex-wrap:wrap}
    .swatch{width:28px;height:28px;border-radius:50%;border:2px solid var(--line);cursor:pointer}
    .swatch.active{box-shadow:0 0 0 3px var(--head-tint-border);border-color:var(--brand2)}
    .toolbar{display:flex;flex-wrap:wrap;gap:8px;margin:8px 0}
    .btn{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border:1px solid var(--line);border-radius:8px;background:#fff;font-weight:600;cursor:pointer}
    .btn.primary{background:var(--header-fill);color:#fff;border-color:transparent}
    .btn.ghost{background:#fff;color:var(--brand1)}
    .pill{display:inline-block;padding:2px 6px;border-radius:999px;font-size:11px;border:1px solid var(--line);background:#f2f4f8;color:var(--ink)}
    .context-menu{position:fixed;z-index:5000;display:none;min-width:140px;background:#fff;border:1px solid var(--line);border-radius:10px;box-shadow:0 12px 24px rgba(15,23,42,.18);padding:4px 0}
    .context-menu button{display:block;width:100%;padding:8px 14px;border:none;background:none;text-align:left;font:inherit;color:var(--ink);cursor:pointer}
    .context-menu button:hover{background:var(--head-tint)}

    .truncate-text{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    /* Cards/heads (CFOE style) */
    .card{background:#fff;border:1px solid var(--line);border-radius:14px;box-shadow:0 6px 18px rgba(15,23,42,.05);margin:0 0 12px}
    .card-head{padding:12px;background:var(--head-tint);border-bottom:1px solid var(--head-tint-border);font-weight:700;color:#334155;border-radius:14px 14px 0 0}
    .card-body{padding:12px}

    /* Notes (markdown-ish) */
    .notes-wrap{display:grid;gap:12px;grid-template-columns:1fr}
    /* Note list items styling */
    .note-item{display:flex;align-items:center;gap:8px;padding:4px 0;font-size:14px;color:var(--ink);}
    /* Larger checkboxes and bullet icons for better usability */
    .note-item.note-check input[type="checkbox"]{margin-right:8px;width:18px;height:18px;cursor:pointer;}
    .note-item.note-bullet .bullet-icon{font-size:18px;line-height:1; color:var(--ink);}
    /* When a checklist item is completed, strike it through and mute its colour */
    .note-item.note-check.done span{ text-decoration: line-through; color: var(--ink-light); }
    .bullet-icon{font-size:10px;color:var(--muted);margin-right:8px;}
    textarea{width:100%;min-height:220px;padding:8px 10px;border:1px solid var(--line);border-radius:10px;font:inherit;background:#fff;color:var(--ink);resize:vertical}
    .preview{border:1px solid var(--line);border-radius:10px;padding:10px;background:#fff;min-height:220px;overflow:auto}
    .preview h1,.preview h2,.preview h3{margin:6px 0}
    .preview ul{padding-left:20px}
    .preview input[type="checkbox"]{transform:translateY(1px)}

    /* Styling for the interactive checklist list on the notes page */
    .notes-list{
      border:1px solid var(--line);
      border-radius:10px;
      padding:10px;
      background:#fff;
      min-height:120px;
    }

    /* Override default note item styles to create a modern checklist with circular checkboxes and drag support */
    .note-item{display:flex;align-items:center;gap:8px;padding:8px 0;font-size:16px;color:var(--ink);cursor:grab;}
    .note-item.note-check input[type="checkbox"]{
      appearance:none;
      -webkit-appearance:none;
      width:22px;height:22px;
      border:2px solid var(--line);
      border-radius:50%;
      position:relative;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      margin-right:12px;
      cursor:pointer;
    }
    .note-item.note-check input[type="checkbox"]::after{
      content:'';
      position:absolute;
      width:12px;height:12px;
      border-radius:50%;
      background:var(--brand1);
      opacity:0;
      transition:opacity .15s;
    }
    .note-item.note-check input[type="checkbox"]:checked::after{
      opacity:1;
    }
    .note-item.note-check.done span{
      text-decoration:line-through;
      color:var(--ink-light);
    }
    .note-item.drag-over{
      background: var(--head-tint-border);
    }
    .note-section-title{
      margin:12px 0 4px;
      font-size:12px;
      font-weight:700;
      color:var(--muted);
      letter-spacing:0.05em;
      text-transform:uppercase;
    }
    .note-section-title:first-child{margin-top:0;}
    .note-group-title{
      font-size:13px;
      font-weight:600;
      color:var(--group-title-text,var(--ink));
      margin:12px 0 6px;
      position:relative;
      display:flex;
      align-items:center;
      gap:8px;
      padding:10px 12px;
      border-radius:10px;
      background:var(--group-title-bg,var(--head-tint));
      border:1px solid var(--group-border-color,var(--head-tint-border));
      transition:background .2s,color .2s,border-color .2s;
    }
    .note-group-title.collapsed{opacity:.75;}
    .note-group-title.task-drop{box-shadow:0 0 0 2px var(--brand1);}
    .group-label{flex:1;min-width:0;display:flex;align-items:center;gap:6px;}
    .group-label .group-name{flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
    .group-actions{display:flex;align-items:center;gap:4px;}
    .group-action{border:none;border-radius:6px;padding:4px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;background:rgba(255,255,255,.6);color:inherit;transition:background .2s,opacity .2s;}
    .group-action:hover{background:rgba(255,255,255,.85);}
    .group-action:focus-visible{outline:2px solid var(--brand1);outline-offset:2px;}
    .group-action.group-color{width:22px;height:22px;padding:0;border:1px solid rgba(15,23,42,.15);border-radius:50%;}
    .group-action.group-color.has-color{border-color:transparent;}
    .group-action.group-color-clear{width:22px;height:22px;padding:0;border:1px solid rgba(15,23,42,.15);border-radius:6px;font-size:14px;line-height:1;background:#fff;color:var(--muted);}
    .group-action.group-color-clear:hover{background:rgba(15,23,42,.08);}
    .group-action.group-collapse{min-width:22px;font-size:12px;line-height:1;}
    .note-group-title.draggable{cursor:grab;user-select:none;}
    .note-group-title.draggable:active{cursor:grabbing;}
    .note-group-title.dragging{opacity:.7;}
    .note-group-title.drag-over-before::before,.note-group-title.drag-over-after::after{content:'';position:absolute;left:0;right:0;height:2px;background:var(--brand1);border-radius:999px;opacity:.9;}
    .note-group-title.drag-over-before::before{top:-6px;}
    .note-group-title.drag-over-after::after{bottom:-6px;}
    .note-group-container{
      border:1px solid var(--group-border-color,var(--line));
      border-radius:10px;
      padding:4px 8px;
      background:var(--group-fill-color,#fff);
      margin-bottom:8px;
      transition:background .2s,border-color .2s;
    }
    .note-group-container.drag-over{
      border-color:var(--head-tint-border);
      background:var(--head-tint);
    }
    .note-group-container.collapsed{display:none;}
    .note-group-container.empty{
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--muted);
      font-size:13px;
      padding:12px;
    }
    .note-group-placeholder{padding:8px 0;color:var(--muted);font-size:12px;text-align:center;}
    .note-item.note-task{
      cursor:pointer;
      align-items:flex-start;
    }
    .note-item.note-task input[type="checkbox"]{
      margin-top:4px;
    }
    .note-task-content{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .note-task-title{font-weight:600;color:var(--ink);}
    .note-text{
      flex:1;
      min-width:0;
      display:block;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .note-task-meta{font-size:12px;color:var(--muted);}
    .note-item.note-task.done .note-task-title{
      text-decoration:line-through;
      color:var(--ink-light);
    }
    .modal-checklist{list-style:none;padding-left:0;margin:8px 0 0;}
    .modal-checklist li{display:flex;align-items:center;gap:8px;margin-bottom:6px;}
    .modal-checklist li:last-child{margin-bottom:0;}
    .modal-checklist input[type="checkbox"]{width:18px;height:18px;}
    .modal-checklist input[type="text"]{flex:1;padding:6px 8px;border:1px solid var(--line);border-radius:8px;background:#fff;font:inherit;}
    .modal-check-remove{background:none;border:none;color:var(--muted);font-size:16px;line-height:1;cursor:pointer;padding:4px;}
    .modal-check-remove:hover{color:var(--ink);}

    /* Modal overlay for editing items from the checklist */
    .modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.3);z-index:2000;}
    .modal-card{width:100%;max-width:420px;}

    /* Tasks */
    .row{display:grid;gap:12px}
    .row-3{grid-template-columns:repeat(3,minmax(0,1fr))}
    .field label{display:block;margin-bottom:4px;font-size:12px;font-weight:700;color:#475569}
    .field input,.field select{width:100%;padding:8px 10px;border:1px solid var(--line);border-radius:10px;background:#fff}
    .tag-chips{display:flex;flex-wrap:wrap;gap:6px}
    .chip-tag{display:inline-flex;align-items:center;gap:4px;padding:4px 8px;border-radius:999px;border:1px solid var(--line);background:#fff;cursor:pointer}
    .chip-tag.selected{background:var(--finish-pill-bg);border-color:var(--finish-pill-border);color:var(--finish-pill-text)}
    .chip-tag.group-chip{position:relative;padding-right:26px;cursor:grab;user-select:none;display:inline-flex;align-items:center;gap:6px;}
    .chip-tag.group-chip:active{cursor:grabbing;}
    .chip-tag.group-chip.dragging{opacity:.65;}
    .chip-tag.group-chip.is-collapsed:not(.dragging){opacity:.7;}
    .chip-tag.group-chip.drag-over-before,.chip-tag.group-chip.drag-over-after{border-color:var(--brand1);box-shadow:0 0 0 2px var(--head-tint-border);}
    .chip-tag.group-chip.drag-over-before::before,.chip-tag.group-chip.drag-over-after::after{content:'';position:absolute;left:8px;right:8px;height:2px;background:var(--brand1);border-radius:999px;opacity:.9;}
    .chip-tag.group-chip.drag-over-before::before{top:-4px;}
    .chip-tag.group-chip.drag-over-after::after{bottom:-4px;}
    .chip-tag.group-chip .remove{position:absolute;right:8px;top:50%;transform:translateY(-50%);font-size:12px;opacity:.7;cursor:pointer;}
    #groupPalette.drag-over-end{outline:2px dashed var(--brand1);outline-offset:6px;border-radius:16px;padding-bottom:8px;}
    .chip-tag.group-chip .remove:hover{opacity:1;}
    .chip-tag.group-chip .color-dot{width:12px;height:12px;border-radius:50%;border:1px solid rgba(15,23,42,.25);background:var(--head-tint);flex-shrink:0;cursor:pointer;}
    .chip-tag.group-chip .chip-label{font-weight:600;}
    .task-list{display:grid;gap:10px}
    .task-card{border:1px solid var(--line);border-radius:12px;padding:10px;background:#fff}
    .task-title{
      font-weight:700;
      color:var(--ink);
      flex:1;
      min-width:0;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .subtle{color:var(--muted);font-size:12px}
    .checklist{margin:6px 0 0;padding-left:22px}

    /* Kanban */
    .kanban{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));align-items:start}
    .col{background:var(--kanban-col);border:1px solid var(--line);border-radius:12px;min-height:240px;display:flex;flex-direction:column}
    .col-head{padding:10px 12px;border-bottom:1px solid var(--line);font-weight:700}
    .col-body{padding:10px;display:flex;flex-direction:column;gap:8px;flex:1}
    .drag-over{outline:2px dashed #93c5fd;background:var(--kanban-drop)}
    .kb-card{background:#fff;border:1px solid var(--line);border-radius:10px;padding:8px;cursor:grab}
    .kb-card-title{
      font-weight:700;
      color:var(--ink);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    /* Table */
    .grid{overflow:auto;border:1px solid var(--line);border-radius:12px;background:#fff}
    table{width:100%;border-collapse:collapse}
    thead th{position:sticky;top:0;background:var(--thead-bg);color:var(--thead-text);font-size:12px;font-weight:700;border-bottom:1px solid var(--line);text-align:left;padding:8px;white-space:nowrap;cursor:pointer}
    tbody td{border-bottom:1px solid var(--line);padding:0}
    .cell{padding:8px 10px;outline:none}
    .cell[contenteditable="true"]{min-width:80px;display:block}
    .row-selected td{background:rgba(59,130,246,.06)}
    .sort-asc::after{content:" \25B2";font-size:10px}
    .sort-desc::after{content:" \25BC";font-size:10px}

    /* Calendar */
    .calendar-grid{
      display:grid;
      grid-template-columns:repeat(7,minmax(var(--calendar-cell-min-width),1fr));
      border:1px solid var(--line);
      border-radius:12px;
      overflow:hidden;
      max-width:calc(var(--calendar-cell-max-width) * 7);
      margin:0 auto;
    }
    .calendar-grid .day-of-week{
      background:var(--thead-bg);
      color:var(--thead-text);
      font-weight:700;
      text-align:center;
      padding:4px;
      border-bottom:1px solid var(--line);
    }
    .calendar-cell{
      min-height:100px;
      min-width:var(--calendar-cell-min-width);
      border-right:1px solid var(--line);
      border-bottom:1px solid var(--line);
      padding:4px;
      position:relative;
      cursor:pointer;
    }
    .calendar-cell:last-child{border-right:none;}
    .calendar-cell .date-num{
      font-size:12px;
      font-weight:700;
      color:var(--muted);
    }
    .calendar-cell.today{
      background:rgba(255,138,0,0.12);
      border-color:rgba(255,138,0,0.45);
    }
    .calendar-cell.today .date-num{ color:var(--brand1); }
    .calendar-cell.selected{
      box-shadow:inset 0 0 0 2px var(--brand2);
    }
    .calendar-mini{
      border:1px solid var(--line);
      border-radius:12px;
      overflow:hidden;
    }
    .calendar-mini .calendar-cell{
      min-height:60px;
      font-size:12px;
    }
    .calendar-mini .day-of-week{
      font-size:11px;
      padding:3px;
    }
    .calendar-mini .calendar-cell .date-num{
      font-size:11px;
    }
    .calendar-task{
      font-size:12px;
      margin:2px 0;
      padding:2px 4px;
      border:1px solid var(--line);
      border-radius:6px;
      background:#fff;
      cursor:grab;
      max-width:calc(100% - var(--ellipsis-reserve, 0px) - var(--ellipsis-reserve-percent, 0%));
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .calendar-cell.drag-over{
      background:var(--kanban-drop);
    }

    @media (max-width:1200px){
      .calendar-grid{
        --calendar-cell-max-width:170px;
        max-width:calc(var(--calendar-cell-max-width) * 7);
      }
    }

    @media (max-width:1024px){
      .calendar-grid{
        --calendar-cell-min-width:100px;
        --calendar-cell-max-width:150px;
        max-width:100%;
      }
      .calendar-cell{
        min-width:var(--calendar-cell-min-width);
      }
    }

    @media (max-width:820px){
      .calendar-grid{
        --calendar-cell-min-width:80px;
        --calendar-cell-max-width:120px;
      }
    }

    @media (max-width:640px){
      .calendar-grid{
        --calendar-cell-min-width:60px;
        --calendar-cell-max-width:90px;
      }
    }

    @media (max-width:480px){
      .calendar-grid{
        --calendar-cell-min-width:48px;
        --calendar-cell-max-width:68px;
      }
    }

    /* Day (My Day) */
    .day-layout{
      display:flex;
      flex-direction:column;
      gap:16px;
    }
    .day-main{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .day-sidebar{
      flex:0 0 280px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .day-sidebar-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }
    .day-sidebar-header .btn{flex:0 0 auto;padding:4px 8px;}
    .day-unscheduled{
      margin-bottom:8px;
      display:flex;
      flex-direction:column;
      gap:4px;
      min-height:40px;
      border:1px dashed var(--line);
      border-radius:8px;
      padding:4px;
    }
    .day-grid{
      border:1px solid var(--line);
      border-radius:12px;
      overflow:hidden;
    }
    .day-slot{
      display:flex;
      align-items:stretch;
      gap:6px;
      padding:2px 6px;
      border-bottom:1px solid var(--line);
      min-height:40px;
    }
    .day-slot:last-child{border-bottom:none;}
    .day-time{
      width:50px;
      font-size:12px;
      color:var(--muted);
    }
    .day-cell{
      flex:1;
      display:flex;
      align-items:center;
      min-height:32px;
      border:1px solid var(--line);
      border-radius:8px;
      padding:0;
      background:#fff;
      transition:border-color .15s ease, box-shadow .15s ease, background .15s ease;
      position:relative;
    }
    .day-cell.has-value{
      background:#f8fafc;
    }
    .day-slot-input{
      width:100%;
      padding:6px 10px;
      border:none;
      background:transparent;
      font:inherit;
      color:var(--ink);
    }
    .day-slot-input:focus{
      outline:none;
    }
    .day-cell:focus-within{
      border-color:rgba(255,138,0,0.55);
      box-shadow:0 0 0 2px rgba(255,138,0,0.2);
      background:#fff8f1;
    }
    .day-slot-input::placeholder{color:var(--muted);}
    .day-cell.drag-over{
      border-color:var(--kanban-drop);
      background:var(--kanban-drop);
      box-shadow:none;
    }
    .day-unscheduled .calendar-task,
    .day-grid .calendar-task{
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      gap:2px;
      white-space:normal;
    }
    .calendar-task-title{
      font-weight:600;
      color:var(--ink);
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .calendar-task-note{font-size:12px;color:var(--muted);}
    .calendar-task-meta{font-size:12px;color:var(--muted);}

    .task-details{
      margin-top:8px;
      font-size:13px;
      line-height:1.4;
      color:var(--ink);
      white-space:pre-wrap;
    }

    .kanban-detail{
      margin-top:4px;
      font-size:12px;
      color:var(--muted);
      white-space:pre-wrap;
    }
    .checkbox-label{
      display:flex;
      align-items:center;
      gap:6px;
      font-weight:700;
      font-size:12px;
      color:#475569;
    }
    .checkbox-label input{width:16px;height:16px;}

    /* Responsive (SharePoint mobile safe-area aware) */
    @media (max-width: 900px){ .row-3{grid-template-columns:1fr} }
    @media (max-width: 900px){ .day-sidebar{display:none;} .day-layout{flex-direction:column;} }
    @media (max-width: 700px){ .notes-wrap{grid-template-columns:1fr} }
    @media (max-width: 600px){
      .wrap{width:calc(100% + var(--sp-left-offset,0px) + var(--sp-right-offset,0px));padding-left:max(var(--sp-mobile-gutter),env(safe-area-inset-left,0px));padding-right:max(var(--sp-mobile-gutter),env(safe-area-inset-right,0px));margin-left:calc(-1 * var(--sp-left-offset,0px));margin-right:calc(-1 * var(--sp-right-offset,0px))}
      .tab-buttons{display:none}
      .tab-select{display:block;flex:1 1 160px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="tab-bar">
      <div class="tab-buttons">
        <button data-view="notes" class="active">Main</button>
        <button data-view="tasks">Tasks</button>
        <button data-view="kanban">Kanban</button>
        <button data-view="table">Table</button>
        <button data-view="calendar">Calendar</button>
        <button data-view="day">My Day</button>
      </div>
      <select class="tab-select" id="tabSelect" aria-label="Navigate">
        <option value="notes">Main</option>
        <option value="tasks">Tasks</option>
        <option value="kanban">Kanban</option>
        <option value="table">Table</option>
        <option value="calendar">Calendar</option>
        <option value="day">My Day</option>
      </select>
      <div id="controlBtns">
        <span class="chip ok" id="chipSave"><span class="dot"></span><span>Saved</span></span>
        <button class="gear" id="btnThemePicker" title="Theme & tools">⚙️</button>
      </div>
      <div class="theme-picker" id="themePicker" role="dialog" aria-modal="false">
        <h5>Colour theme</h5>
        <div class="swatches" id="swatches"></div>
        <div class="toolbar" style="margin-top:10px;border-top:1px solid var(--line);padding-top:10px">
          <button class="btn" id="btnExportJson">Export JSON</button>
          <button class="btn" id="btnImportJson">Import JSON</button>
          <input type="file" id="importFile" accept="application/json" style="display:none"/>
        </div>
        <!-- Future: SharePoint exports (commented out scaffolding) -->
        <!--
        <div class="toolbar" style="border-top:1px solid var(--line);padding-top:10px">
          <button class="btn ghost" id="btnPushList">Push to SP List</button>
          <button class="btn ghost" id="btnUploadLibrary">Upload to SP Library</button>
        </div>
        -->
      </div>
    </div>

    <!-- MAIN VIEW -->
    <section id="view-notes" class="card">
      <div class="card-head">Main</div>
      <div class="card-body">
        <!-- Input area for adding new checklist items -->
        <div class="toolbar" style="margin-bottom:8px;flex-wrap:wrap;gap:8px;">
          <input id="newItemInput" class="btn" placeholder="Add new item…" style="flex:1;padding:6px 10px;min-width:160px"/>
          <select id="newItemGroupSelect" class="btn" aria-label="Assign to group" style="min-width:160px;"></select>
          <button class="btn" id="btnQuickAddGroup" type="button">+ Group</button>
          <button class="btn" id="btnAddNoteItem">Add</button>
        </div>
        <!-- Hidden textarea to store checklist items (kept for compatibility with internal logic) -->
        <textarea id="notesInput" style="display:none"></textarea>
        <!-- Container for interactive checklist items -->
        <div class="notes-list" id="notesPreview" aria-live="polite"></div>
      </div>
    </section>

    <!-- TASKS VIEW -->
    <section id="view-tasks" class="card" style="display:none">
      <div class="card-head">Tasks</div>
      <div class="card-body">
        <div class="row row-3">
          <div class="field"><label>Title</label><input id="taskTitle"></div>
          <div class="field"><label>Status</label>
            <select id="taskStatus">
              <option value="backlog">Backlog</option>
              <option value="doing">Doing</option>
              <option value="done">Done</option>
            </select>
          </div>
          <div class="field"><label>Priority</label>
            <select id="taskPriority">
              <option value="1">P1</option>
              <option value="2" selected>P2</option>
              <option value="3">P3</option>
            </select>
          </div>
        </div>
        <!-- Due date input -->
        <div class="row" style="margin-top:8px">
          <div class="field"><label>Due Date</label><input type="date" id="taskDueDate"></div>
        </div>
        <div class="row" style="margin-top:8px">
          <div class="field"><label>Details</label><textarea id="taskDetails" rows="3" placeholder="Add more context"></textarea></div>
        </div>
        <div class="row" style="margin-top:8px">
          <div class="field"><label>Tags (toggle to select)</label>
            <div class="tag-chips" id="tagPalette"></div>
            <div class="toolbar">
              <input id="newTagInput" class="btn" placeholder="New tag name" style="padding:6px 10px"/>
              <button class="btn" id="btnAddTag">Add Tag</button>
            </div>
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div class="field"><label>Item Group</label>
            <select id="taskGroupSelect" class="btn" style="width:100%;max-width:240px;min-width:160px" aria-label="Select item group"></select>
            <div class="toolbar" style="margin-top:6px;gap:6px;">
              <input id="newGroupInput" class="btn" placeholder="New group name" style="padding:6px 10px;flex:1;min-width:160px"/>
              <button class="btn" id="btnAddGroup" type="button">Add Group</button>
            </div>
            <div class="tag-chips" id="groupPalette" style="margin-top:6px"></div>
          </div>
        </div>
        <div class="row">
          <div class="field"><label>Checklist</label>
            <div class="toolbar">
              <input id="checkItem" class="btn" placeholder="Add checklist item" style="padding:6px 10px"/>
              <button class="btn" id="btnAddCheck">Add</button>
            </div>
            <ul id="checklist" class="checklist"></ul>
          </div>
        </div>
        <div class="toolbar" style="margin-top:8px">
          <button class="btn primary" id="btnAddTask">Add Task</button>
          <span class="subtle" id="taskCount"></span>
          <button class="btn" id="btnClearAll" style="margin-left:auto">Clear All</button>
        </div>
        <div class="task-list" id="taskList" style="margin-top:12px"></div>
      </div>
    </section>

    <!-- KANBAN VIEW -->
    <section id="view-kanban" class="card" style="display:none">
      <div class="card-head">Kanban</div>
      <div class="card-body">
        <div class="toolbar" style="margin-bottom:8px;flex-wrap:wrap;gap:8px;">
          <select id="kanbanGrouping" class="btn" aria-label="Group Kanban" style="flex:0 0 auto;min-width:150px;">
            <option value="tab">Tab</option>
            <option value="priority">Priority</option>
            <option value="category">Category</option>
            <option value="date">Date</option>
          </select>
          <input id="kanbanNewItemInput" class="btn" placeholder="Add new item…" style="flex:1;padding:6px 10px;min-width:200px"/>
          <button class="btn" id="btnAddKanbanItem">Add</button>
        </div>
        <div class="kanban" id="kanban"></div>
      </div>
    </section>

    <!-- TABLE VIEW -->
    <section id="view-table" class="card" style="display:none">
      <div class="card-head">Table (Excel‑like)</div>
      <div class="card-body">
        <div class="grid">
          <table id="taskTable">
            <thead>
              <tr>
                <th data-key="title">Title</th>
                <th data-key="status">Status</th>
                <th data-key="group">Group</th>
                <th data-key="priority">Priority</th>
                <th data-key="dueDate">Due</th>
                <th data-key="tags">Tags</th>
                <th data-key="details">Details</th>
                <th data-key="createdAt">Created</th>
              </tr>
            </thead>
            <tbody id="gridBody"></tbody>
          </table>
        </div>
      </div>
    </section>

    <!-- CALENDAR VIEW -->
    <section id="view-calendar" class="card" style="display:none">
      <div class="card-head">Calendar</div>
      <div class="card-body">
        <div class="toolbar" style="margin-bottom:8px;">
          <input id="calendarNewItemInput" class="btn" placeholder="Add new item…" style="flex:1;padding:6px 10px"/>
          <button class="btn" id="btnAddCalendarItem">Add</button>
        </div>
        <div class="toolbar" style="margin-bottom:8px; display:flex; align-items:center; justify-content:space-between;">
          <button class="btn" id="prevMonthBtn">&lt;</button>
          <div id="calendarMonthLabel" style="font-weight:700"></div>
          <button class="btn" id="nextMonthBtn">&gt;</button>
        </div>
        <div class="calendar-grid" id="calendarGrid" aria-label="Calendar"></div>
      </div>
    </section>

    <!-- DAY VIEW (My Day) -->
    <section id="view-day" class="card" style="display:none">
      <div class="card-head"><span id="dayLabel">My Day</span></div>
      <div class="card-body">
        <div class="day-layout">
          <div class="day-main">
            <div style="font-weight:600;">Unscheduled tasks</div>
            <div id="dayUnscheduled" class="day-unscheduled"></div>
            <div class="day-grid" id="dayGrid" aria-label="Day schedule"></div>
          </div>
          <aside class="day-sidebar" aria-label="Month overview">
            <div class="day-sidebar-header">
              <button class="btn" id="daySidebarPrev" aria-label="Previous month">&lt;</button>
              <div id="daySidebarMonthLabel" style="font-weight:700"></div>
              <button class="btn" id="daySidebarNext" aria-label="Next month">&gt;</button>
            </div>
            <div class="calendar-grid calendar-mini" id="daySidebarCalendar" aria-label="Mini calendar"></div>
          </aside>
        </div>
      </div>
    </section>
  </div>

  <!-- Modal for editing items (status, priority, tags) -->
  <div id="taskModal" class="modal-overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal-card card">
      <div class="card-head">Edit Item</div>
      <div class="card-body">
        <div class="field"><label>Title</label>
          <input type="text" id="modalTitleInput" placeholder="Task title"/>
        </div>
        <div class="field"><label>Status</label>
          <select id="modalStatusSelect">
            <option value="backlog">Backlog</option>
            <option value="doing">Doing</option>
            <option value="done">Done</option>
          </select>
        </div>
        <div class="field">
          <label class="checkbox-label"><input type="checkbox" id="modalCompleteToggle"> Mark complete</label>
        </div>
        <div class="field"><label>Priority</label>
          <select id="modalPrioritySelect">
            <option value="1">P1</option>
            <option value="2">P2</option>
            <option value="3">P3</option>
          </select>
        </div>
        <div class="field"><label>Due Date</label>
          <input type="date" id="modalDueDate"/>
        </div>
        <div class="field"><label>Details</label>
          <textarea id="modalDetails" rows="4" placeholder="Add notes or context"></textarea>
        </div>
        <div class="field"><label>Checklist</label>
          <div class="toolbar">
            <input id="modalCheckInput" class="btn" placeholder="Add checklist item" style="padding:6px 10px"/>
            <button class="btn" id="modalAddCheck">Add</button>
          </div>
          <ul id="modalChecklist" class="checklist modal-checklist"></ul>
        </div>
        <div class="field"><label>Tags</label>
          <div id="modalTagContainer" class="tag-chips"></div>
          <div class="toolbar">
            <input id="modalNewTagInput" class="btn" placeholder="New tag name" style="padding:6px 10px"/>
            <button class="btn" id="modalAddTag">Add Tag</button>
          </div>
        </div>
        <div class="field"><label>Item Group</label>
          <select id="modalGroupSelect" class="btn" style="width:100%;max-width:240px;min-width:160px"></select>
        </div>
        <div class="toolbar" style="margin-top:12px">
          <button id="modalSaveBtn" class="btn primary">Save</button>
          <button id="modalCancelBtn" class="btn">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  (function(){
    // ---------- Theme (CFOE/TFI style) ----------
    const THEMES = [
      { key:'regal',   name:'Regal',   colors:['#ff8a00','#ff6a00'] },
      { key:'ocean',   name:'Ocean',   colors:['#0ea5e9','#3b82f6'] },
      { key:'royal',   name:'Royal',   colors:['#8b5cf6','#7c3aed'] },
      { key:'emerald', name:'Emerald', colors:['#10b981','#22c55e'] }
    ];
    function hexToRgb(hex){ let h=hex.replace('#',''); if(h.length===3) h=h.split('').map(c=>c+c).join(''); const n=parseInt(h,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; }
    function applyTheme(key){ const t=THEMES.find(x=>x.key===key)||THEMES[0]; const root=document.documentElement; root.style.setProperty('--brand1', t.colors[0]); root.style.setProperty('--brand2', t.colors[1]); root.style.setProperty('--header-fill', `linear-gradient(90deg, ${t.colors[0]}, ${t.colors[1]})`); const rgb=hexToRgb(t.colors[0]); root.style.setProperty('--head-tint',`rgba(${rgb.r},${rgb.g},${rgb.b},0.12)`); root.style.setProperty('--head-tint-border',`rgba(${rgb.r},${rgb.g},${rgb.b},0.4)`); try{localStorage.setItem('n6-theme', t.key);}catch(e){} updateSwatches(t.key); }
    function initTheme(){ let stored=null; try{stored=localStorage.getItem('n6-theme')}catch(e){} applyTheme(stored||'regal'); document.getElementById('btnThemePicker').style.background = getComputedStyle(document.documentElement).getPropertyValue('--header-fill')||'linear-gradient(90deg,#ff8a00,#ff6a00)'; }
    function buildSwatches(){ const wrap=document.getElementById('swatches'); wrap.innerHTML=''; THEMES.forEach(t=>{ const s=document.createElement('div'); s.className='swatch'; s.style.background=`linear-gradient(90deg, ${t.colors[0]}, ${t.colors[1]})`; s.dataset.theme=t.key; s.title=t.name; s.addEventListener('click',e=>{ applyTheme(t.key); hidePicker(); }); wrap.appendChild(s); }); updateSwatches(); }
    function updateSwatches(active){ document.querySelectorAll('.swatch').forEach(el=>{ el.classList.toggle('active', el.dataset.theme === (active||localStorage.getItem('n6-theme')||'regal')); }); }
    const picker=document.getElementById('themePicker'); function showPicker(){ picker.style.display='block'; } function hidePicker(){ picker.style.display='none'; }
    document.getElementById('btnThemePicker').addEventListener('click', (e)=>{ e.stopPropagation(); picker.style.display === 'block' ? hidePicker() : showPicker(); });
    document.addEventListener('click', (e)=>{ if(picker.style.display==='block'){ const within = picker.contains(e.target) || e.target.id==='btnThemePicker'; if(!within) hidePicker(); } });

    // ---------- State ----------
    const LSKEY='n6-notes-tasks-v1';
    const KANBAN_GROUP_OPTIONS=['tab','priority','category','date'];
    let state=null, unsynced=false;
    // Track the index of the note item currently being dragged for reordering
    let dragNoteIndex = null;
    let dragManualTaskId = null;
    let dragGroupName = null;
    const defaultState = ()=>({
      notes:'',
      tags:['Work','Home','Urgent'],
      tasks:[], // {id,title,status,priority,tags[],checklist:[{t,done}],createdAt}
      manualOrder:[],
      itemGroups:['General'],
      groupMeta:{},
      settings:{theme:'regal',kanbanGrouping:'tab',lastGroup:''}
    });
    function save(){ try{ localStorage.setItem(LSKEY, JSON.stringify(state)); }catch(e){} setSaved(true); }
    function load(){
      try{ const raw=localStorage.getItem(LSKEY); state = raw? JSON.parse(raw): defaultState(); }
      catch(e){ state=defaultState(); }
      if(!Array.isArray(state.tags)) state.tags=[];
      if(!Array.isArray(state.tasks)) state.tasks=[];
      if(!Array.isArray(state.itemGroups)) state.itemGroups=[];
      state.itemGroups = ensureItemGroups();
      const extraGroups = new Set();
      state.tasks = state.tasks.filter(t => t && typeof t === 'object').map(t => {
        if(typeof t.details !== 'string') t.details = '';
        t.status = normalizeStatusValue(t.status);
        ensureLastActiveStatus(t);
        t.group = normalizeGroupValue(t.group);
        if(t.group) extraGroups.add(t.group);
        return t;
      });
      extraGroups.forEach(name => {
        if(name && !state.itemGroups.includes(name)){
          state.itemGroups.push(name);
        }
      });
      state.itemGroups = ensureItemGroups();
      if(!Array.isArray(state.manualOrder)) state.manualOrder = [];
      if(!state.settings || typeof state.settings !== 'object'){
        state.settings = {theme:'regal',kanbanGrouping:'tab',lastGroup:''};
      }
      if(typeof state.settings.theme !== 'string') state.settings.theme='regal';
      if(!KANBAN_GROUP_OPTIONS.includes(state.settings.kanbanGrouping)){
        state.settings.kanbanGrouping='tab';
      }
      const lastGroup = normalizeGroupValue(state.settings.lastGroup);
      state.settings.lastGroup = lastGroup && state.itemGroups.includes(lastGroup) ? lastGroup : '';
    }
    function setSaved(ok){ const chip=document.getElementById('chipSave'); chip.classList.remove('ok','warn'); chip.classList.add(ok?'ok':'warn'); chip.lastElementChild.textContent = ok? 'Saved' : 'Unsaved'; unsynced=!ok; }
    function markDirty(){ setSaved(false); save(); }

    function sanitizeGroupName(name){
      if(typeof name !== 'string') return '';
      return name.trim().replace(/\s+/g,' ').slice(0, 80);
    }
    function normalizeGroupValue(name){
      const normalized = sanitizeGroupName(name);
      return normalized;
    }
    function sanitizeHexColor(value){
      if(typeof value !== 'string') return '';
      const trimmed = value.trim();
      if(!trimmed) return '';
      const match = /^#?([0-9a-f]{3}|[0-9a-f]{6})$/i.exec(trimmed);
      if(!match) return '';
      let hex = match[1].toLowerCase();
      if(hex.length === 3){
        hex = hex.split('').map(ch => ch + ch).join('');
      }
      return `#${hex}`;
    }
    function sanitizeGroupMetaEntry(entry){
      if(!entry || typeof entry !== 'object') return { color:'', collapsed:false };
      const color = sanitizeHexColor(entry.color);
      return { color: color || '', collapsed: !!entry.collapsed };
    }
    function ensureGroupMeta(){
      if(!state || typeof state !== 'object') return {};
      if(!state.groupMeta || typeof state.groupMeta !== 'object') state.groupMeta = {};
      const normalizedEntries = {};
      Object.keys(state.groupMeta).forEach(key => {
        const normalizedKey = normalizeGroupValue(key);
        const sanitized = sanitizeGroupMetaEntry(state.groupMeta[key]);
        if(!normalizedEntries.hasOwnProperty(normalizedKey)){
          normalizedEntries[normalizedKey] = sanitized;
        } else {
          if(!normalizedEntries[normalizedKey].color && sanitized.color){
            normalizedEntries[normalizedKey].color = sanitized.color;
          }
          if(sanitized.collapsed){
            normalizedEntries[normalizedKey].collapsed = true;
          }
        }
      });
      if(!normalizedEntries['']){
        normalizedEntries[''] = { color:'', collapsed:false };
      }
      const groups = Array.isArray(state.itemGroups) ? state.itemGroups.map(normalizeGroupValue) : [];
      groups.forEach(name => {
        if(!normalizedEntries.hasOwnProperty(name)){
          normalizedEntries[name] = { color:'', collapsed:false };
        } else {
          normalizedEntries[name] = sanitizeGroupMetaEntry(normalizedEntries[name]);
        }
      });
      Object.keys(normalizedEntries).forEach(key => {
        const entry = normalizedEntries[key];
        entry.color = sanitizeHexColor(entry.color) || '';
        entry.collapsed = !!entry.collapsed;
      });
      state.groupMeta = normalizedEntries;
      return state.groupMeta;
    }
    function ensureGroupPrefsEntry(name){
      ensureGroupMeta();
      const key = normalizeGroupValue(name);
      if(!state.groupMeta.hasOwnProperty(key)){
        state.groupMeta[key] = { color:'', collapsed:false };
      } else {
        state.groupMeta[key] = sanitizeGroupMetaEntry(state.groupMeta[key]);
      }
      return state.groupMeta[key];
    }
    function getGroupPrefs(name){
      ensureGroupMeta();
      const key = normalizeGroupValue(name);
      if(!state.groupMeta.hasOwnProperty(key)){
        return { color:'', collapsed:false };
      }
      return sanitizeGroupMetaEntry(state.groupMeta[key]);
    }
    function getGroupColor(name){
      return getGroupPrefs(name).color;
    }
    function isGroupCollapsed(name){
      return getGroupPrefs(name).collapsed;
    }
    function setGroupColor(name, color){
      const entry = ensureGroupPrefsEntry(name);
      const sanitized = sanitizeHexColor(color);
      if(entry.color === sanitized) return false;
      entry.color = sanitized || '';
      return true;
    }
    function setGroupCollapsed(name, collapsed){
      const entry = ensureGroupPrefsEntry(name);
      const next = !!collapsed;
      if(entry.collapsed === next) return false;
      entry.collapsed = next;
      return true;
    }
    function getDefaultGroupColor(){
      const brand = getComputedStyle(document.documentElement).getPropertyValue('--brand1');
      return sanitizeHexColor(brand) || '#ff8a00';
    }
    let groupColorPicker = null;
    let pendingGroupColorTarget = '';
    function ensureGroupColorPicker(){
      if(groupColorPicker) return groupColorPicker;
      groupColorPicker = document.createElement('input');
      groupColorPicker.type = 'color';
      groupColorPicker.id = 'groupColorPicker';
      groupColorPicker.style.position = 'fixed';
      groupColorPicker.style.left = '-9999px';
      document.body.appendChild(groupColorPicker);
      groupColorPicker.addEventListener('input', () => {
        if(!pendingGroupColorTarget) return;
        const changed = setGroupColor(pendingGroupColorTarget, groupColorPicker.value);
        if(changed){
          markDirty();
          renderGroupManager();
          renderNotesList();
        }
      });
      groupColorPicker.addEventListener('change', () => {
        pendingGroupColorTarget = '';
      });
      return groupColorPicker;
    }
    function openGroupColorPicker(name){
      const picker = ensureGroupColorPicker();
      const key = normalizeGroupValue(name);
      pendingGroupColorTarget = key;
      const current = getGroupColor(key);
      picker.value = current || getDefaultGroupColor();
      picker.click();
    }
    function hexToRgba(hex, alpha){
      const rgb = hexToRgb(hex);
      return `rgba(${rgb.r},${rgb.g},${rgb.b},${alpha})`;
    }
    function getReadableTextColor(hex){
      const rgb = hexToRgb(hex);
      const luminance = (0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b) / 255;
      return luminance > 0.6 ? '#0f172a' : '#ffffff';
    }
    function ensureItemGroups(){
      if(!Array.isArray(state.itemGroups)) state.itemGroups = [];
      const seen = new Set();
      const cleaned = [];
      state.itemGroups.forEach(name => {
        const normalized = sanitizeGroupName(name);
        if(!normalized) return;
        const key = normalized.toLowerCase();
        if(seen.has(key)) return;
        seen.add(key);
        cleaned.push(normalized);
      });
      if(!cleaned.length){
        cleaned.push('General');
      }
      state.itemGroups = cleaned;
      ensureGroupMeta();
      return state.itemGroups;
    }
    function addItemGroup(name){
      const normalized = normalizeGroupValue(name);
      if(!normalized) return false;
      ensureItemGroups();
      if(state.itemGroups.includes(normalized)) return false;
      state.itemGroups.push(normalized);
      ensureGroupPrefsEntry(normalized);
      return true;
    }
    function removeItemGroup(name){
      const normalized = normalizeGroupValue(name);
      ensureItemGroups();
      const idx = state.itemGroups.indexOf(normalized);
      if(idx < 0) return false;
      state.itemGroups.splice(idx,1);
      if(state.groupMeta && Object.prototype.hasOwnProperty.call(state.groupMeta, normalized)){
        delete state.groupMeta[normalized];
      }
      state.tasks.forEach(task => {
        if(normalizeGroupValue(task.group) === normalized){
          task.group = '';
        }
      });
      if(state.settings && normalizeGroupValue(state.settings.lastGroup) === normalized){
        state.settings.lastGroup = '';
      }
      ensureItemGroups();
      return true;
    }
    function getLastGroup(){
      if(!state || !state.settings) return '';
      const normalized = normalizeGroupValue(state.settings.lastGroup);
      return normalized && state.itemGroups.includes(normalized) ? normalized : '';
    }
    function setLastGroup(name){
      if(!state.settings || typeof state.settings !== 'object'){
        state.settings = {theme:'regal',kanbanGrouping:'tab',lastGroup:''};
      }
      const normalized = normalizeGroupValue(name);
      state.settings.lastGroup = normalized && state.itemGroups.includes(normalized) ? normalized : '';
    }
    function setTaskGroup(task, name){
      if(!task || typeof task !== 'object') return false;
      const normalized = normalizeGroupValue(name);
      const current = normalizeGroupValue(task.group);
      if(current === normalized) return false;
      task.group = normalized;
      if(normalized && !state.itemGroups.includes(normalized)){
        state.itemGroups.push(normalized);
        ensureGroupPrefsEntry(normalized);
      }
      if(!normalized && current && state.settings && normalizeGroupValue(state.settings.lastGroup) === current){
        state.settings.lastGroup = '';
      }
      return true;
    }

    function moveItemGroupToIndex(name, targetIndex){
      const normalized = normalizeGroupValue(name);
      if(!normalized) return false;
      const groups = ensureItemGroups();
      const fromIdx = groups.indexOf(normalized);
      if(fromIdx < 0) return false;
      const [item] = groups.splice(fromIdx, 1);
      let dest = Number.isFinite(targetIndex) ? Math.round(targetIndex) : groups.length;
      if(dest < 0) dest = 0;
      if(dest > groups.length) dest = groups.length;
      groups.splice(dest, 0, item);
      return dest !== fromIdx;
    }

    function reorderItemGroups(sourceName, targetName, insertAfter){
      const source = normalizeGroupValue(sourceName);
      const target = normalizeGroupValue(targetName);
      if(!source || !target || source === target) return false;
      if(source === '__ungrouped' || target === '__ungrouped') return false;
      ensureItemGroups();
      const groups = state.itemGroups;
      const fromIdx = groups.indexOf(source);
      const toIdx = groups.indexOf(target);
      if(fromIdx < 0 || toIdx < 0) return false;
      let insertIdx = insertAfter ? toIdx + 1 : toIdx;
      if(fromIdx < insertIdx) insertIdx -= 1;
      return moveItemGroupToIndex(source, insertIdx);
    }

    function commitGroupReorder(){
      markDirty();
      refreshTaskViews();
    }

    function refreshTaskShellViews(){
      renderGroupSelectors();
      renderGroupManager();
      renderTasks();
      renderKanban();
      renderGrid();
      renderCalendar();
      if(selectedDate) renderDay(selectedDate);
    }

    function refreshTaskViews(){
      renderNotesList();
      refreshTaskShellViews();
    }

    function normalizeStatusValue(value){
      if(typeof value!=='string') return 'backlog';
      const trimmed=value.trim().toLowerCase();
      return trimmed||'backlog';
    }
    function ensureLastActiveStatus(task){
      if(!task || typeof task!=='object') return 'backlog';
      const current = typeof task.lastActiveStatus==='string'? task.lastActiveStatus.trim().toLowerCase() : '';
      if(current){ task.lastActiveStatus=current; return current; }
      const status = normalizeStatusValue(task.status);
      if(status==='done'){
        task.lastActiveStatus='backlog';
      } else {
        task.lastActiveStatus=status;
      }
      return task.lastActiveStatus;
    }
    function applyTaskStatus(task,nextStatus){
      if(!task || typeof task!=='object') return false;
      const normalized=normalizeStatusValue(nextStatus);
      const prevStatus=normalizeStatusValue(task.status);
      if(normalized===prevStatus) return false;
      if(prevStatus!=='done'){
        task.lastActiveStatus=prevStatus;
      }
      if(normalized!=='done'){
        task.lastActiveStatus=normalized;
      }
      task.status=normalized;
      return true;
    }
    function setTaskCompletion(task,isDone){
      if(!task || typeof task!=='object') return false;
      if(isDone){
        return applyTaskStatus(task,'done');
      }
      const restore=ensureLastActiveStatus(task);
      return applyTaskStatus(task, restore);
    }
    function compareTaskDisplayOrder(a,b){
      if(a===b) return 0;
      if(!a) return 1;
      if(!b) return -1;
      const doneA = normalizeStatusValue(a.status)==='done';
      const doneB = normalizeStatusValue(b.status)==='done';
      if(doneA!==doneB) return doneA?1:-1;
      const dueA = (typeof a.dueDate==='number' && Number.isFinite(a.dueDate))? a.dueDate : Infinity;
      const dueB = (typeof b.dueDate==='number' && Number.isFinite(b.dueDate))? b.dueDate : Infinity;
      if(dueA!==dueB) return dueA - dueB;
      const priorityA = Number(a.priority)||0;
      const priorityB = Number(b.priority)||0;
      if(priorityA!==priorityB) return priorityA - priorityB;
      return (a.createdAt||0) - (b.createdAt||0);
    }

    // ---------- Router ----------
    // Extend views to include calendar and day
    const views={
      notes: document.getElementById('view-notes'),
      tasks: document.getElementById('view-tasks'),
      kanban: document.getElementById('view-kanban'),
      table: document.getElementById('view-table'),
      calendar: document.getElementById('view-calendar'),
      day: document.getElementById('view-day')
    };
    // selectedDate for day view
    let selectedDate = null;
    let pendingDaySlotFocus = null;
    function showView(id){
      Object.keys(views).forEach(k=> views[k].style.display = k===id? '':'none');
      document.querySelectorAll('.tab-buttons button').forEach(b=> b.classList.toggle('active', b.dataset.view===id));
      document.getElementById('tabSelect').value = id;
      document.body.classList.toggle('table-full', id==='table');
      if(id==='kanban'){ renderKanban(); }
      if(id==='table'){ renderGrid(); }
      if(id==='tasks'){ renderTagPalette(); renderTasks(); }
      if(id==='notes'){ renderNotes(); }
      if(id==='calendar'){ renderCalendar(); }
      if(id==='day'){
        // Default to today if no date selected
        if(!selectedDate){
          const today=new Date();
          selectedDate = today.getFullYear() + '-' + String(today.getMonth()+1).padStart(2,'0') + '-' + String(today.getDate()).padStart(2,'0');
        }
        renderDay(selectedDate);
      }
    }
    document.querySelectorAll('.tab-buttons button').forEach(b=> b.addEventListener('click', ()=>showView(b.dataset.view)) );
    document.getElementById('tabSelect').addEventListener('change', (e)=>showView(e.target.value));

    const kanbanGroupingSelect=document.getElementById('kanbanGrouping');
    if(kanbanGroupingSelect){
      kanbanGroupingSelect.value=getKanbanGroupingValue();
      kanbanGroupingSelect.addEventListener('change',(e)=>{
        const value=e.target.value;
        const next=KANBAN_GROUP_OPTIONS.includes(value)? value : 'tab';
        if(!state.settings || typeof state.settings!=='object'){
          state.settings={theme:'regal',kanbanGrouping:next};
        }
        if(state.settings.kanbanGrouping!==next){
          state.settings.kanbanGrouping=next;
          markDirty();
        }
        renderKanban();
      });
    }

    // ---------- Notes ----------
    const notesInput = document.getElementById('notesInput'); const notesPreview = document.getElementById('notesPreview');
    function esc(s){ return String(s==null?'':s).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    function md(mini){
      let s = String(mini||'');
      // headings #, ##, ###
      s = s.replace(/^###\s*(.*)$/gm,'<h3>$1</h3>').replace(/^##\s*(.*)$/gm,'<h2>$1</h2>').replace(/^#\s*(.*)$/gm,'<h1>$1</h1>');
      // bold **text**
      s = s.replace(/\*\*(.*?)\*\*/g,'<strong>$1</strong>');
      // checklist - [ ] item / - [x] item
      s = s.replace(/^- \[ \] (.*)$/gm,'<div><label><input type="checkbox" disabled> $1</label></div>');
      s = s.replace(/^- \[x\] (.*)$/gmi,'<div><label><input type="checkbox" checked disabled> $1</label></div>');
      // bullets - item
      // First convert remaining "- " lines to <li>
      const UL_TOKEN = '___ULTOKEN___';
      s = s.replace(/^(?:- (.*)(?:\n|$))+?/gm, (m)=>{
        const items = m.trim().split(/\n/).map(line=> line.replace(/^-\s+/, '').trim()).filter(Boolean);
        if(!items.length) return m;
        return UL_TOKEN + items.map(it=>`<li>${esc(it)}</li>`).join('\n') + UL_TOKEN;
      });
      s = esc(s);
      // revert tokens into <ul>
      s = s.replace(new RegExp(UL_TOKEN,'g'),'</ul>').replace(/<\/ul><li/g,'<ul><li');
      // finally clean double </ul>
      return s;
    }

    let truncateObserver;
    function ensureTruncateObserver(){
      if(!truncateObserver){
        truncateObserver = new ResizeObserver(entries => {
          entries.forEach(entry => {
            const target = entry.target;
            if(target && target._truncateMeta){
              updateTruncateTooltip(target);
            }
          });
        });
      }
      return truncateObserver;
    }

    function updateTruncateTooltip(el){
      const meta = el._truncateMeta;
      if(!meta) return;
      if(!el.isConnected){
        ensureTruncateObserver().unobserve(el);
        return;
      }
      const rect = el.getBoundingClientRect();
      const width = rect.width || el.clientWidth;
      const scrollWidth = el.scrollWidth;
      if(width === 0 && scrollWidth === 0){
        return;
      }
      const needsEllipsis = scrollWidth - width > 1;
      meta.truncated = needsEllipsis;
      const tooltipParts = [];
      if(needsEllipsis && meta.base){
        tooltipParts.push(meta.base);
      }
      if(meta.extraTooltip){
        tooltipParts.push(meta.extraTooltip);
      }
      if(tooltipParts.length){
        el.setAttribute('title', tooltipParts.join('\n'));
      } else {
        el.removeAttribute('title');
      }
    }

    function scheduleTruncateUpdate(el){
      requestAnimationFrame(() => {
        updateTruncateTooltip(el);
        requestAnimationFrame(() => updateTruncateTooltip(el));
      });
    }

    function applyTruncatedTitle(el, text, options={}){
      const fallback = options.fallback ?? '(Untitled)';
      const extraTooltipRaw = options.extraTooltip;
      const extraTooltip = extraTooltipRaw == null ? '' : String(extraTooltipRaw);
      const raw = text == null ? '' : String(text);
      const base = raw.trim().length ? raw.trim() : fallback;
      const reservePxRaw = Number(options.ellipsisReservePx);
      const ellipsisReservePx = Number.isFinite(reservePxRaw) && reservePxRaw > 0 ? reservePxRaw : 0;
      const reservePercentRaw = Number(options.ellipsisReservePercent);
      let ellipsisReservePercent = 0;
      if(Number.isFinite(reservePercentRaw) && reservePercentRaw > 0){
        ellipsisReservePercent = Math.min(Math.max(reservePercentRaw, 0), 0.9);
      }
      el.textContent = base;
      el.dataset.fullTitle = base;
      el.classList.add('truncate-text');
      if(el.tagName === 'SPAN' && el.style.display === ''){
        el.style.display = 'block';
      }
      if(ellipsisReservePx){
        el.style.setProperty('--ellipsis-reserve', `${ellipsisReservePx}px`);
      } else {
        el.style.removeProperty('--ellipsis-reserve');
      }
      if(ellipsisReservePercent){
        el.style.setProperty('--ellipsis-reserve-percent', `${ellipsisReservePercent * 100}%`);
      } else {
        el.style.removeProperty('--ellipsis-reserve-percent');
      }
      const meta = { base, extraTooltip, truncated: false, ellipsisReservePx, ellipsisReservePercent };
      el._truncateMeta = meta;
      ensureTruncateObserver().observe(el);
      scheduleTruncateUpdate(el);
      return meta;
    }
    // Build interactive list of notes as a sortable checklist
    function renderNotesList(){
      notesPreview.innerHTML = '';
      const manualTasks = state.tasks.filter(t => !t.fromNotes);
      const manualOrder = ensureManualOrder();
      const orderIndex = new Map(manualOrder.map((id, idx) => [id, idx]));
      const baseIndex = new Map();
      manualTasks.forEach((task, idx) => baseIndex.set(task.id, idx));
      const tasksSorted = manualTasks.slice().sort((a, b) => {
        const doneA = String(a.status||'').toLowerCase()==='done';
        const doneB = String(b.status||'').toLowerCase()==='done';
        if(doneA!==doneB) return doneA?1:-1;
        const fallbackA = baseIndex.has(a.id) ? baseIndex.get(a.id) : manualTasks.length;
        const fallbackB = baseIndex.has(b.id) ? baseIndex.get(b.id) : manualTasks.length;
        const idxA = orderIndex.has(a.id) ? orderIndex.get(a.id) : manualOrder.length + fallbackA;
        const idxB = orderIndex.has(b.id) ? orderIndex.get(b.id) : manualOrder.length + fallbackB;
        if(idxA!==idxB) return idxA - idxB;
        return (a.createdAt||0) - (b.createdAt||0);
      });
      let appendedMainHeader = false;
      const ensureMainHeader = () => {
        if(appendedMainHeader) return;
        const header = document.createElement('div');
        header.className = 'note-section-title';
        header.textContent = 'Main Checklist';
        notesPreview.appendChild(header);
        appendedMainHeader = true;
      };
      const groupContainers = new Map();
      const seenGroupKeys = new Set();
      const groupOrder = [];
      ensureItemGroups().forEach(name => {
        const key = normalizeGroupValue(name);
        if(key && !seenGroupKeys.has(key)){
          seenGroupKeys.add(key);
          groupOrder.push(key);
        }
      });
      tasksSorted.forEach(task => {
        const key = normalizeGroupValue(task.group);
        if(key && !seenGroupKeys.has(key)){
          seenGroupKeys.add(key);
          groupOrder.push(key);
        }
      });
      const hasUngrouped = tasksSorted.some(task => !normalizeGroupValue(task.group));
      if(hasUngrouped){
        groupOrder.push('__ungrouped');
      }
      const ensureGroupPlaceholder = (container) => {
        if(!container) return;
        const hasItems = container.querySelector('.note-item');
        let placeholder = container.querySelector('.note-group-placeholder');
        if(hasItems){
          if(placeholder) placeholder.remove();
          container.classList.remove('empty');
        } else {
          if(!placeholder){
            placeholder = document.createElement('div');
            placeholder.className = 'note-group-placeholder';
            placeholder.textContent = 'Drop items here';
            container.appendChild(placeholder);
          }
          container.classList.add('empty');
        }
      };
      const ensureGroupSection = (key) => {
        ensureMainHeader();
        const normalizedKey = key || '__ungrouped';
        if(groupContainers.has(normalizedKey)) return groupContainers.get(normalizedKey);
        const metaKey = normalizedKey === '__ungrouped' ? '' : normalizedKey;
        const displayName = normalizedKey === '__ungrouped' ? 'Ungrouped' : normalizedKey;
        const title = document.createElement('div');
        title.className = 'note-group-title';
        title.dataset.group = normalizedKey;
        if(normalizedKey !== '__ungrouped'){
          title.classList.add('draggable');
          title.draggable = true;
          title.title = 'Drag to reorder groups';
          title.addEventListener('dragstart', (e) => {
            dragGroupName = normalizedKey;
            title.classList.add('dragging');
            if(e.dataTransfer){
              e.dataTransfer.effectAllowed = 'move';
              e.dataTransfer.setData('text/plain', normalizedKey);
            }
          });
          title.addEventListener('dragend', () => {
            clearGroupDragState();
          });
        } else {
          title.title = displayName;
        }
        const label = document.createElement('div');
        label.className = 'group-label';
        const nameSpan = document.createElement('span');
        nameSpan.className = 'group-name';
        nameSpan.textContent = displayName;
        label.appendChild(nameSpan);
        const actions = document.createElement('div');
        actions.className = 'group-actions';
        const colorBtn = document.createElement('button');
        colorBtn.type = 'button';
        colorBtn.className = 'group-action group-color';
        colorBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          openGroupColorPicker(metaKey);
        });
        colorBtn.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          e.stopPropagation();
          if(setGroupColor(metaKey, '')){
            markDirty();
            renderGroupManager();
            renderNotesList();
          }
        });
        colorBtn.addEventListener('mousedown', (e) => e.stopPropagation());
        const clearColorBtn = document.createElement('button');
        clearColorBtn.type = 'button';
        clearColorBtn.className = 'group-action group-color-clear';
        clearColorBtn.textContent = '×';
        clearColorBtn.title = 'Clear colour';
        clearColorBtn.setAttribute('aria-label', `Clear colour for ${displayName}`);
        clearColorBtn.hidden = true;
        clearColorBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if(setGroupColor(metaKey, '')){
            markDirty();
            renderGroupManager();
            renderNotesList();
          }
        });
        clearColorBtn.addEventListener('mousedown', (e) => e.stopPropagation());
        const collapseBtn = document.createElement('button');
        collapseBtn.type = 'button';
        collapseBtn.className = 'group-action group-collapse';
        collapseBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const next = !isGroupCollapsed(metaKey);
          if(setGroupCollapsed(metaKey, next)){
            markDirty();
            renderGroupManager();
            renderNotesList();
          }
        });
        collapseBtn.addEventListener('mousedown', (e) => e.stopPropagation());
        label.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          const next = !isGroupCollapsed(metaKey);
          if(setGroupCollapsed(metaKey, next)){
            markDirty();
            renderGroupManager();
            renderNotesList();
          }
        });
        actions.appendChild(colorBtn);
        actions.appendChild(clearColorBtn);
        actions.appendChild(collapseBtn);
        title.appendChild(label);
        title.appendChild(actions);
        const container = document.createElement('div');
        container.className = 'note-group-container';
        container.dataset.group = normalizedKey;
        ensureGroupPlaceholder(container);
        const updateVisualState = () => {
          const prefs = getGroupPrefs(metaKey);
          const color = prefs.color;
          const collapsed = !!prefs.collapsed;
          clearColorBtn.title = `Clear colour for ${displayName}`;
          clearColorBtn.setAttribute('aria-label', `Clear colour for ${displayName}`);
          if(color){
            const textColor = getReadableTextColor(color);
            title.style.setProperty('--group-title-bg', color);
            title.style.setProperty('--group-title-text', textColor);
            title.style.setProperty('--group-border-color', color);
            container.style.setProperty('--group-border-color', color);
            container.style.setProperty('--group-fill-color', hexToRgba(color, 0.12));
            title.classList.add('has-color');
            container.classList.add('has-color');
            colorBtn.classList.add('has-color');
            colorBtn.style.background = color;
            colorBtn.style.borderColor = 'transparent';
            colorBtn.style.color = textColor;
            clearColorBtn.hidden = false;
            if(textColor === '#ffffff'){
              collapseBtn.style.background = 'rgba(255,255,255,.25)';
              collapseBtn.style.color = '#ffffff';
            } else {
              collapseBtn.style.background = '';
              collapseBtn.style.color = '';
            }
          } else {
            title.style.removeProperty('--group-title-bg');
            title.style.removeProperty('--group-title-text');
            title.style.removeProperty('--group-border-color');
            container.style.removeProperty('--group-border-color');
            container.style.removeProperty('--group-fill-color');
            title.classList.remove('has-color');
            container.classList.remove('has-color');
            colorBtn.classList.remove('has-color');
            colorBtn.style.background = '';
            colorBtn.style.borderColor = '';
            colorBtn.style.color = '';
            clearColorBtn.hidden = true;
            collapseBtn.style.background = '';
            collapseBtn.style.color = '';
          }
          colorBtn.title = color ? `Change colour (${color}). Use × to clear.` : 'Set colour';
          colorBtn.setAttribute('aria-label', color ? `Change colour for ${displayName}. Use clear to remove.` : `Set colour for ${displayName}`);
          const collapsedLabel = collapsed ? `Expand ${displayName}` : `Collapse ${displayName}`;
          collapseBtn.textContent = collapsed ? '▸' : '▾';
          collapseBtn.title = collapsedLabel;
          collapseBtn.setAttribute('aria-label', collapsedLabel);
          title.classList.toggle('collapsed', collapsed);
          container.classList.toggle('collapsed', collapsed);
          container.style.display = collapsed ? 'none' : '';
        };
        updateVisualState();
        const clearTaskHighlights = () => {
          document.querySelectorAll('.note-group-title').forEach(el => el.classList.remove('task-drop','drag-over-before','drag-over-after'));
        };
        container.addEventListener('dragover', (e) => {
          if(!dragManualTaskId) return;
          e.preventDefault();
          container.classList.add('drag-over');
        });
        container.addEventListener('dragleave', () => {
          container.classList.remove('drag-over');
        });
        container.addEventListener('drop', (e) => {
          e.preventDefault();
          container.classList.remove('drag-over');
          const id = dragManualTaskId || (e.dataTransfer ? e.dataTransfer.getData('text/plain') : '');
          dragManualTaskId = null;
          clearTaskHighlights();
          if(!id) return;
          applyManualTaskDrop(id, metaKey);
        });
        title.addEventListener('dragover', (e) => {
          if(dragManualTaskId){
            e.preventDefault();
            title.classList.add('task-drop');
            title.classList.remove('drag-over-before','drag-over-after');
            return;
          }
          if(normalizedKey === '__ungrouped') return;
          if(!dragGroupName || dragGroupName === normalizedKey) return;
          e.preventDefault();
          const rect = title.getBoundingClientRect();
          const after = e.clientY > rect.top + rect.height / 2;
          title.classList.toggle('drag-over-after', after);
          title.classList.toggle('drag-over-before', !after);
        });
        title.addEventListener('dragleave', () => {
          title.classList.remove('task-drop','drag-over-before','drag-over-after');
        });
        title.addEventListener('drop', (e) => {
          if(dragManualTaskId){
            e.preventDefault();
            e.stopPropagation();
            const id = dragManualTaskId || (e.dataTransfer ? e.dataTransfer.getData('text/plain') : '');
            dragManualTaskId = null;
            title.classList.remove('task-drop');
            clearTaskHighlights();
            if(id) applyManualTaskDrop(id, metaKey);
            return;
          }
          if(normalizedKey === '__ungrouped') return;
          if(!dragGroupName) return;
          e.preventDefault();
          e.stopPropagation();
          const from = dragGroupName || (e.dataTransfer ? e.dataTransfer.getData('text/plain') : '');
          const rect = title.getBoundingClientRect();
          const after = e.clientY > rect.top + rect.height / 2;
          const changed = reorderItemGroups(from, normalizedKey, after);
          clearGroupDragState();
          if(changed){
            commitGroupReorder();
          }
        });
        notesPreview.appendChild(title);
        notesPreview.appendChild(container);
        groupContainers.set(normalizedKey, container);
        return container;
      };
      if(!groupOrder.length && manualTasks.length){
        ensureGroupSection('__ungrouped');
      }
      groupOrder.forEach(key => ensureGroupSection(key));
      tasksSorted.forEach(task => {
        const groupKey = normalizeGroupValue(task.group) || '__ungrouped';
        const container = ensureGroupSection(groupKey);
        const placeholder = container.querySelector('.note-group-placeholder');
        if(placeholder) placeholder.remove();
        container.classList.remove('empty');
        const wrapper = document.createElement('div');
        wrapper.className = 'note-item note-check';
        wrapper.draggable = true;
        wrapper.dataset.taskId = task.id;
        wrapper.dataset.groupKey = groupKey;
        if(task.status === 'done'){ wrapper.classList.add('done'); }
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = task.status === 'done';
        checkbox.addEventListener('change', (e) => {
          const changed = setTaskCompletion(task, e.target.checked);
          wrapper.classList.toggle('done', task.status === 'done');
          if(changed){
            markDirty();
          }
          refreshTaskShellViews();
          renderNotesList();
        });
        wrapper.addEventListener('dragstart', (e) => {
          dragManualTaskId = task.id;
          if(e.dataTransfer){
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', task.id);
          }
        });
        wrapper.addEventListener('dragend', () => {
          dragManualTaskId = null;
          wrapper.classList.remove('drag-over');
          document.querySelectorAll('.note-group-title').forEach(title => title.classList.remove('task-drop','drag-over-before','drag-over-after'));
        });
        wrapper.addEventListener('dragover', (e) => {
          if(!dragManualTaskId) return;
          e.preventDefault();
          wrapper.classList.add('drag-over');
        });
        wrapper.addEventListener('dragleave', () => {
          wrapper.classList.remove('drag-over');
        });
        wrapper.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const fromId = dragManualTaskId || (e.dataTransfer ? e.dataTransfer.getData('text/plain') : '');
          const toId = task.id;
          wrapper.classList.remove('drag-over');
          dragManualTaskId = null;
          document.querySelectorAll('.note-group-title').forEach(title => title.classList.remove('task-drop','drag-over-before','drag-over-after'));
          if(!fromId || !toId) return;
          const rect = wrapper.getBoundingClientRect();
          const insertAfter = e.clientY > rect.top + rect.height / 2;
          const host = wrapper.closest('.note-group-container');
          const targetGroupKey = host ? (host.dataset.group || '__ungrouped') : '__ungrouped';
          const targetGroup = targetGroupKey === '__ungrouped' ? '' : targetGroupKey;
          const movedTask = state.tasks.find(x => x && x.id === fromId && !x.fromNotes);
          const groupChanged = movedTask ? setTaskGroup(movedTask, targetGroup) : false;
          const changed = reorderManualTaskOrder(fromId, toId, insertAfter);
          if(groupChanged || changed){
            markDirty();
            renderGroupSelectors();
            renderGroupManager();
            renderNotesList();
            refreshTaskShellViews();
          }
        });
        const span = document.createElement('span');
        span.className = 'note-text';
        applyTruncatedTitle(span, task.title);
        wrapper.appendChild(checkbox);
        wrapper.appendChild(span);
        wrapper.addEventListener('click', (ev) => {
          if(ev.target.closest('input')) return;
          openTaskModalForId(task.id);
        });
        container.appendChild(wrapper);
      });
      groupContainers.forEach(container => ensureGroupPlaceholder(container));
      const lines = String(state.notes||'').split(/\r?\n/);
      lines.forEach((raw, idx) => {
        if(!raw || /^\s*$/.test(raw)) return;
        // Determine whether the item is checked
        let match = raw.match(/^\s*-\s*\[( |x|X)\]\s+(.*)$/);
        let done = false;
        let text = '';
        if(match){
          done = (match[1] || ' ').toLowerCase() === 'x';
          text = (match[2] || '').trim();
        } else {
          match = raw.match(/^\s*-\s*(.*)$/);
          text = match ? (match[1] || '').trim() : raw.trim();
        }
        if(!text) return;
        ensureMainHeader();
        const div = document.createElement('div');
        div.className = 'note-item note-check';
        div.draggable = true;
        div.dataset.lineIndex = idx;
        // Determine unique key for mapping to task
        const noteKey = 'notes:' + text.toLowerCase();
        div.dataset.noteKey = noteKey;
        div.dataset.noteLineIndex = idx;
        const relatedTask = state.tasks.find(t => t.noteKey === noteKey);
        if(relatedTask){
          div.dataset.taskId = relatedTask.id;
        }
        if(done) div.classList.add('done');
        // Checkbox element: clicking marks complete
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = done;
        checkbox.dataset.lineIndex = idx;
        checkbox.addEventListener('change', (e) => {
          const i = parseInt(e.target.dataset.lineIndex, 10);
          const arr = String(state.notes||'').split(/\r?\n/);
          const line = arr[i] || '';
          // Replace existing prefix or add one if absent
          if(/^\s*-\s*\[(?: |x|X)\]/.test(line)){
            arr[i] = line.replace(/^\s*-\s*\[(?: |x|X)\]/, '- ' + (e.target.checked ? '[x]' : '[ ]'));
          } else if (/^\s*-\s*/.test(line)) {
            arr[i] = '- ' + (e.target.checked ? '[x]' : '[ ]') + line.replace(/^\s*-\s*/, ' ');
          } else {
            arr[i] = '- ' + (e.target.checked ? '[x] ' : '[ ] ') + line;
          }
          state.notes = arr.join('\n');
          notesInput.value = state.notes;
          syncNotesToTasks();
          markDirty();
          renderNotesList();
          refreshTaskShellViews();
        });
        const span = document.createElement('span');
        span.className = 'note-text';
        applyTruncatedTitle(span, text);
        span.addEventListener('click', (e) => {
          // Only open modal on left click
          openTaskModalByKey(noteKey);
        });
        // Compose item
        div.appendChild(checkbox);
        div.appendChild(span);
        // Drag-and-drop handlers
        div.addEventListener('dragstart', (e) => {
          dragNoteIndex = idx;
          if(e.dataTransfer){ e.dataTransfer.effectAllowed = 'move'; }
        });
        div.addEventListener('dragover', (e) => {
          e.preventDefault();
          div.classList.add('drag-over');
        });
        div.addEventListener('dragleave', (e) => {
          div.classList.remove('drag-over');
        });
        div.addEventListener('drop', (e) => {
          e.preventDefault();
          div.classList.remove('drag-over');
          const from = dragNoteIndex;
          let to = parseInt(div.dataset.lineIndex, 10);
          if(isNaN(from) || isNaN(to)) return;
          const rect = div.getBoundingClientRect();
          const insertAfter = e.clientY > rect.top + rect.height / 2;
          if(insertAfter) to += 1;
          const arr = String(state.notes||'').split(/\r?\n/);
          if(from < 0 || from >= arr.length) return;
          const [moved] = arr.splice(from, 1);
          let insertIndex = Math.max(0, Math.min(arr.length, to));
          if(insertIndex > from) insertIndex -= 1;
          arr.splice(insertIndex, 0, moved);
          state.notes = arr.join('\n');
          notesInput.value = state.notes;
          syncNotesToTasks();
          markDirty();
          renderNotesList();
          refreshTaskShellViews();
          dragNoteIndex = null;
        });
        div.addEventListener('dragend', () => {
          dragNoteIndex = null;
          div.classList.remove('drag-over');
        });
        notesPreview.appendChild(div);
      });
    }

    function renderNotes(){ notesInput.value = state.notes||''; renderNotesList(); }
    // When notes text changes, update state, sync tasks, and refresh views
    notesInput.addEventListener('input', ()=>{
      state.notes = notesInput.value;
      syncNotesToTasks();
      markDirty();
      renderNotesList();
      refreshTaskShellViews();
    });
    function appendNewChecklistItem(rawText){
      const text = (rawText || '').trim();
      if(!text) return false;
      const arr = String(state.notes || '').split(/\r?\n/).filter(l => l && !/^\s*$/.test(l));
      arr.push('- [ ] ' + text);
      state.notes = arr.join('\n');
      notesInput.value = state.notes;
      syncNotesToTasks();
      markDirty();
      renderNotesList();
      refreshTaskShellViews();
      return true;
    }

    function registerNewItemInput(inputId, buttonId){
      const input = document.getElementById(inputId);
      const button = document.getElementById(buttonId);
      if(!input || !button) return;
      const commit = () => {
        const text = (input.value || '').trim();
        if(!text) return;
        if(inputId === 'newItemInput'){
          const selectedGroup = newItemGroupSelect ? normalizeGroupValue(newItemGroupSelect.value || getLastGroup()) : getLastGroup();
          const created = createManualTask(text, { group: selectedGroup });
          if(created){
            if(newItemGroupSelect && selectedGroup){
              newItemGroupSelect.value = selectedGroup;
            }
            setLastGroup(selectedGroup);
            markDirty();
            refreshTaskViews();
          }
          input.value = '';
          return;
        }
        if(appendNewChecklistItem(input.value)){
          input.value = '';
        }
      };
      button.addEventListener('click', commit);
      input.addEventListener('keypress', (e) => {
        if(e.key === 'Enter'){
          e.preventDefault();
          commit();
        }
      });
    }

    [
      ['newItemInput', 'btnAddNoteItem'],
      ['kanbanNewItemInput', 'btnAddKanbanItem'],
      ['calendarNewItemInput', 'btnAddCalendarItem']
    ].forEach(([inputId, buttonId]) => registerNewItemInput(inputId, buttonId));
    function createManualTask(title, overrides={}){
      const trimmed = (title || '').trim();
      if(!trimmed) return null;
      const now = Date.now();
      const status = normalizeStatusValue(overrides.status || 'backlog');
      const groupName = normalizeGroupValue(overrides.group != null ? overrides.group : getLastGroup());
      if(groupName && !state.itemGroups.includes(groupName)){
        state.itemGroups.push(groupName);
      }
      const task = {
        id: now.toString(36) + Math.random().toString(36).slice(2),
        title: trimmed,
        status,
        priority: Number.isFinite(overrides.priority) ? overrides.priority : 2,
        tags: Array.isArray(overrides.tags) ? overrides.tags.slice() : [],
        checklist: Array.isArray(overrides.checklist) ? overrides.checklist.map(item => ({
          t: String(item?.t || '').trim(),
          done: !!item?.done
        })).filter(entry => entry.t) : [],
        createdAt: Number.isFinite(overrides.createdAt) ? overrides.createdAt : now,
        dueDate: Number.isFinite(overrides.dueDate) ? overrides.dueDate : getTodayTimestamp(),
        startTime: Number.isFinite(overrides.startTime) ? overrides.startTime : null,
        details: typeof overrides.details === 'string' ? overrides.details : '',
        group: groupName
      };
      task.lastActiveStatus = status === 'done' ? 'backlog' : status;
      state.tasks.unshift(task);
      const manualOrder = ensureManualOrder().filter(id => id !== task.id);
      manualOrder.unshift(task.id);
      state.manualOrder = manualOrder;
      return task;
    }

    function updateTaskTitleAndSync(taskId, nextTitle){
      const task = state.tasks.find(t => t && t.id === taskId);
      if(!task) return false;
      const trimmed = (nextTitle || '').trim();
      if(!trimmed) return false;
      if(task.title === trimmed) return false;
      if(task.fromNotes){
        const lines = String(state.notes || '').split(/\r?\n/);
        const target = (task.title || '').trim().toLowerCase();
        const idx = lines.findIndex(line => {
          const clean = line.replace(/^\s*-\s*\[(?: |x|X)\]\s*/, '').replace(/^\s*-\s*/, '').trim().toLowerCase();
          return clean === target;
        });
        if(idx < 0) return false;
        const line = lines[idx];
        const hasCheckbox = /^\s*-\s*\[(?: |x|X)\]/.test(line);
        const prefix = hasCheckbox ? (task.status === 'done' ? '- [x] ' : '- [ ] ') : '- ';
        lines[idx] = prefix + trimmed;
        state.notes = lines.join('\n');
        notesInput.value = state.notes;
        task.title = trimmed;
        task.noteKey = 'notes:' + trimmed.toLowerCase();
        syncNotesToTasks();
        return true;
      }
      task.title = trimmed;
      return true;
    }
    function insertAtCursor(el, str){ const s=el.selectionStart||0, e=el.selectionEnd||0, v=el.value; el.value = v.slice(0,s) + str + v.slice(e); el.focus(); const pos = s + str.length; el.setSelectionRange(pos,pos); }

    // Auto-continue checklist items on Enter: always add '- [ ] ' prefix when continuing a list
    notesInput.addEventListener('keydown', (e) => {
      if (e.key !== 'Enter') return;
      const start = notesInput.selectionStart|0, end = notesInput.selectionEnd|0;
      if (start !== end) return;
      const v = notesInput.value; const before = v.slice(0, start);
      const lineStart = before.lastIndexOf('\n') + 1;
      const line = v.slice(lineStart, start);
      // Determine if current line is part of a list (starts with '- ' optionally followed by [ ] or [x])
      const listMatch = /^\s*-\s*(\[(?: |x|X)\])?/.test(line);
      if (!listMatch) return;
      e.preventDefault();
      // Determine if only the prefix exists and no text after
      const stripped = line.replace(/^\s*-\s*/, '').trim();
      const onlyPrefix = stripped === '' || /^\[(?: |x|X)\]\s*$/.test(stripped);
      if (onlyPrefix) {
        const newVal = v.slice(0, lineStart) + v.slice(start);
        notesInput.value = newVal;
        notesInput.setSelectionRange(lineStart, lineStart);
        notesInput.dispatchEvent(new Event('input'));
        return;
      }
      const insert = '\n- [ ] ';
      const newVal = v.slice(0, start) + insert + v.slice(start);
      const pos = start + insert.length;
      notesInput.value = newVal;
      notesInput.setSelectionRange(pos, pos);
      notesInput.dispatchEvent(new Event('input'));
    });

    // Parse note lines into items (bullets and checklists)
    function parseNoteItems(text){
      const out = [];
      const lines = String(text||'').split(/\r?\n/);
      lines.forEach(raw => {
        // Recognize checklist items (with [ ] or [x])
        let m = raw.match(/^\s*-\s*\[( |x|X)\]\s+(.*)$/);
        if (m) {
          const done = (m[1] || ' ').toLowerCase() === 'x';
          const t = (m[2] || '').trim();
          if (t) out.push({ type: 'check', text: t, done });
          return;
        }
        // Treat any line starting with a dash as an unchecked checklist item
        m = raw.match(/^\s*-\s*(.*)$/);
        if (m) {
          const t = (m[1] || '').trim();
          if (t) out.push({ type: 'check', text: t, done: false });
          return;
        }
      });
      return out;
    }

    function getTodayDateStr(){
      const now = new Date();
      const y = now.getFullYear();
      const m = String(now.getMonth()+1).padStart(2,'0');
      const d = String(now.getDate()).padStart(2,'0');
      return `${y}-${m}-${d}`;
    }
    function parseDateInput(value){
      if(!value) return null;
      const parts = value.split('-');
      if(parts.length!==3) return null;
      const yy = parseInt(parts[0],10);
      const mm = parseInt(parts[1],10)-1;
      const dd = parseInt(parts[2],10);
      if(Number.isNaN(yy) || Number.isNaN(mm) || Number.isNaN(dd)) return null;
      const dt = new Date(yy, mm, dd);
      const ts = dt.getTime();
      return Number.isNaN(ts) ? null : ts;
    }
    function getTodayTimestamp(){
      const ts = parseDateInput(getTodayDateStr());
      return ts != null ? ts : Date.now();
    }
    // Format a timestamp (ms) into YYYY-MM-DD string
    function formatDate(ts){
      if(!ts) return '';
      const dt = new Date(ts);
      const y = dt.getFullYear();
      const m = String(dt.getMonth()+1).padStart(2, '0');
      const d = String(dt.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    }

    // Sync notes into uncategorized tasks (from notes)
    function syncNotesToTasks(){
      const items = parseNoteItems(state.notes);
      const oldNotes = state.tasks.filter(t => t.fromNotes);
      const mapOld = new Map(oldNotes.map(t => [t.noteKey, t]));
      const next = [];
      items.forEach(it => {
        const key = 'notes:' + it.text.toLowerCase();
        const prev = mapOld.get(key);
        const prevStatus = prev ? normalizeStatusValue(prev.status) : 'backlog';
        const status = it.done ? 'done' : prevStatus;
        const lastActiveStatus = (() => {
          if(prev){
            const stored = typeof prev.lastActiveStatus === 'string' ? prev.lastActiveStatus.trim().toLowerCase() : '';
            if(stored) return normalizeStatusValue(stored);
            if(prevStatus !== 'done') return prevStatus;
          }
          if(status !== 'done') return status;
          return 'backlog';
        })();
        next.push({
          id: prev?.id || (Date.now().toString(36) + Math.random().toString(36).slice(2)),
          title: it.text,
          status,
          priority: prev?.priority ?? 2,
          tags: Array.isArray(prev?.tags) ? prev.tags : [],
          checklist: [],
          createdAt: prev?.createdAt || Date.now(),
          dueDate: prev ? (prev.dueDate ?? null) : getTodayTimestamp(),
          startTime: prev?.startTime ?? null,
          details: typeof prev?.details === 'string' ? prev.details : '',
          lastActiveStatus,
          fromNotes: true,
          noteKey: key,
          group: ''
        });
      });
      const manual = state.tasks.filter(t => !t.fromNotes);
      state.tasks = next.concat(manual);
      ensureManualOrder();
    }

    function ensureManualOrder(){
      if(!Array.isArray(state.manualOrder)) state.manualOrder = [];
      const manualTasks = state.tasks.filter(t => t && !t.fromNotes);
      const existing = new Set();
      state.manualOrder = state.manualOrder.filter(id => {
        if(!manualTasks.some(task => task.id === id)) return false;
        if(existing.has(id)) return false;
        existing.add(id);
        return true;
      });
      manualTasks.forEach(task => {
        if(!existing.has(task.id)){
          state.manualOrder.push(task.id);
          existing.add(task.id);
        }
      });
      return state.manualOrder;
    }

    function reorderManualTaskOrder(fromId, toId, insertAfter){
      if(!fromId || !toId || fromId === toId) return false;
      const order = ensureManualOrder().slice();
      const fromIdx = order.indexOf(fromId);
      let targetIdx = order.indexOf(toId);
      if(fromIdx < 0 || targetIdx < 0) return false;
      const [moved] = order.splice(fromIdx, 1);
      if(fromIdx < targetIdx) targetIdx -= 1;
      let insertIndex = insertAfter ? targetIdx + 1 : targetIdx;
      if(insertIndex < 0) insertIndex = 0;
      if(insertIndex > order.length) insertIndex = order.length;
      order.splice(insertIndex, 0, moved);
      state.manualOrder = order;
      return true;
    }

    function moveManualTaskToGroupEnd(taskId, groupName){
      if(!taskId) return false;
      const order = ensureManualOrder().slice();
      const currentIdx = order.indexOf(taskId);
      if(currentIdx < 0) return false;
      const manualTasks = state.tasks.filter(t => t && !t.fromNotes);
      const manualMap = new Map(manualTasks.map(t => [t.id, t]));
      const normalizedGroup = normalizeGroupValue(groupName);
      order.splice(currentIdx, 1);
      let insertIndex = order.length;
      for(let i = order.length - 1; i >= 0; i--){
        const otherId = order[i];
        const otherTask = manualMap.get(otherId);
        if(!otherTask) continue;
        const otherGroup = normalizeGroupValue(otherTask.group);
        if(otherGroup === normalizedGroup){
          insertIndex = i + 1;
          break;
        }
      }
      if(insertIndex < 0) insertIndex = 0;
      if(insertIndex > order.length) insertIndex = order.length;
      order.splice(insertIndex, 0, taskId);
      state.manualOrder = order;
      return true;
    }

    function applyManualTaskDrop(taskId, groupName){
      if(!taskId) return false;
      const task = state.tasks.find(x => x && x.id === taskId && !x.fromNotes);
      if(!task) return false;
      const normalizedGroup = normalizeGroupValue(groupName);
      const groupChanged = setTaskGroup(task, normalizedGroup);
      const orderChanged = moveManualTaskToGroupEnd(taskId, normalizedGroup);
      if(groupChanged || orderChanged){
        markDirty();
        renderGroupSelectors();
        renderGroupManager();
        renderNotesList();
        refreshTaskShellViews();
        return true;
      }
      return false;
    }

    function deleteTask(task){
      if(!task) return;
      if(task.fromNotes){
        const arr = String(state.notes||'').split(/\r?\n/);
        const target = (task.title||'').trim().toLowerCase();
        const idx = arr.findIndex(line => {
          const clean = line.replace(/^\s*-\s*\[(?: |x|X)\]\s*/, '').replace(/^\s*-\s*/, '').trim().toLowerCase();
          return clean === target;
        });
        if(idx >= 0){
          arr.splice(idx, 1);
          state.notes = arr.join('\n');
          notesInput.value = state.notes;
        }
      }
      state.tasks = state.tasks.filter(x => x && x.id !== task.id);
      syncNotesToTasks();
      markDirty();
      renderNotesList();
      refreshTaskShellViews();
    }

    function deleteTaskById(taskId){
      const task = state.tasks.find(t => t && t.id === taskId);
      if(task) deleteTask(task);
    }

    function deleteNoteLine(lineIndex){
      const arr = String(state.notes||'').split(/\r?\n/);
      if(lineIndex < 0 || lineIndex >= arr.length) return;
      arr.splice(lineIndex, 1);
      state.notes = arr.join('\n');
      notesInput.value = state.notes;
      syncNotesToTasks();
      markDirty();
      renderNotesList();
      refreshTaskShellViews();
    }

    // ---------- Item groups ----------
    const groupPaletteEl = document.getElementById('groupPalette');
    const newGroupInput = document.getElementById('newGroupInput');
    const btnAddGroup = document.getElementById('btnAddGroup');
    const taskGroupSelect = document.getElementById('taskGroupSelect');
    const newItemGroupSelect = document.getElementById('newItemGroupSelect');
    const btnQuickAddGroup = document.getElementById('btnQuickAddGroup');
    const modalGroupSelect = document.getElementById('modalGroupSelect');

    function populateGroupSelect(select, options={}){
      if(!select) return;
      const includeBlank = options.includeBlank !== false;
      const blankLabel = options.blankLabel || 'No Group';
      const preferred = normalizeGroupValue(options.preferred);
      const fallback = normalizeGroupValue(options.fallback);
      select.innerHTML='';
      if(includeBlank){
        const opt=document.createElement('option');
        opt.value='';
        opt.textContent=blankLabel;
        select.appendChild(opt);
      }
      ensureItemGroups().forEach(name=>{
        const opt=document.createElement('option');
        opt.value=name;
        opt.textContent=name;
        select.appendChild(opt);
      });
      if(preferred && state.itemGroups.includes(preferred)){
        select.value=preferred;
      } else if(fallback && state.itemGroups.includes(fallback)){
        select.value=fallback;
      } else if(!includeBlank && state.itemGroups.length){
        select.value=state.itemGroups[0];
      } else {
        select.value='';
      }
    }

    function renderGroupSelectors(){
      ensureItemGroups();
      const last = getLastGroup();
      if(newItemGroupSelect){
        const current = normalizeGroupValue(newItemGroupSelect.value) || last;
        populateGroupSelect(newItemGroupSelect, { includeBlank:true, preferred:current, fallback:last, blankLabel:'No Group' });
      }
      if(taskGroupSelect){
        const current = normalizeGroupValue(taskGroupSelect.value) || last;
        populateGroupSelect(taskGroupSelect, { includeBlank:true, preferred:current, fallback:last, blankLabel:'No Group' });
      }
      if(modalGroupSelect){
        const current = normalizeGroupValue(modalGroupSelect.dataset.selected || modalGroupSelect.value || '');
        populateGroupSelect(modalGroupSelect, { includeBlank:true, preferred:current, fallback:'', blankLabel:'No Group' });
      }
    }

    function renderGroupManager(){
      if(!groupPaletteEl) return;
      groupPaletteEl.innerHTML='';
      const last = getLastGroup();
      ensureItemGroups().forEach(name => {
        const chip=document.createElement('button');
        chip.type='button';
        chip.className='chip-tag group-chip';
        if(last === name) chip.classList.add('selected');
        const prefs = getGroupPrefs(name);
        const color = prefs.color;
        const collapsed = prefs.collapsed;
        if(collapsed) chip.classList.add('is-collapsed');
        chip.dataset.group = name;
        chip.dataset.color = color || '';
        chip.dataset.collapsed = collapsed ? 'true' : 'false';
        chip.draggable = true;
        chip.title = collapsed ? 'Drag to reorder groups (collapsed)' : 'Drag to reorder groups';
        chip.textContent='';
        const colorDot=document.createElement('span');
        colorDot.className='color-dot';
        if(color){
          colorDot.style.background=color;
          colorDot.style.borderColor='transparent';
        }
        colorDot.title = color ? `Change colour (${color}). Right-click or double-click to clear.` : 'Set colour';
        colorDot.addEventListener('click', (e)=>{
          e.stopPropagation();
          openGroupColorPicker(name);
        });
        colorDot.addEventListener('contextmenu', (e)=>{
          e.preventDefault();
          e.stopPropagation();
          if(setGroupColor(name, '')){
            markDirty();
            renderGroupManager();
            renderNotesList();
          }
        });
        colorDot.addEventListener('dblclick', (e)=>{
          e.stopPropagation();
          if(setGroupColor(name, '')){
            markDirty();
            renderGroupManager();
            renderNotesList();
          }
        });
        colorDot.addEventListener('mousedown', (e)=> e.stopPropagation());
        const label=document.createElement('span');
        label.className='chip-label';
        label.textContent=name;
        chip.appendChild(colorDot);
        chip.appendChild(label);
        const remove=document.createElement('span');
        remove.className='remove';
        remove.textContent='×';
        remove.setAttribute('aria-hidden','true');
        remove.title='Remove';
        remove.addEventListener('click', (e)=>{
          e.stopPropagation();
          if(!confirm(`Remove group "${name}"? Items will move to Ungrouped.`)) return;
          if(removeItemGroup(name)){
            markDirty();
            renderGroupSelectors();
            renderGroupManager();
            refreshTaskViews();
          }
        });
        chip.addEventListener('click', (e)=>{
          if(e.target === remove) return;
          setLastGroup(name);
          markDirty();
          renderGroupSelectors();
          renderGroupManager();
        });
        chip.addEventListener('dragstart', (e)=>{
          dragGroupName = name;
          chip.classList.add('dragging');
          if(e.dataTransfer){
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', name);
          }
        });
        chip.addEventListener('dragend', () => {
          clearGroupDragState();
        });
        chip.addEventListener('dragover', (e)=>{
          if(!dragGroupName || dragGroupName === name) return;
          e.preventDefault();
          const rect = chip.getBoundingClientRect();
          const after = e.clientX > rect.left + rect.width / 2;
          chip.classList.toggle('drag-over-after', after);
          chip.classList.toggle('drag-over-before', !after);
        });
        chip.addEventListener('dragleave', ()=>{
          chip.classList.remove('drag-over-before','drag-over-after');
        });
        chip.addEventListener('drop', (e)=>{
          if(!dragGroupName) return;
          e.preventDefault();
          e.stopPropagation();
          const from = dragGroupName || (e.dataTransfer ? e.dataTransfer.getData('text/plain') : '');
          const rect = chip.getBoundingClientRect();
          const after = e.clientX > rect.left + rect.width / 2;
          const changed = reorderItemGroups(from, name, after);
          clearGroupDragState();
          if(changed){
            commitGroupReorder();
          }
        });
        chip.appendChild(remove);
        groupPaletteEl.appendChild(chip);
      });
    }

    function clearGroupDragState(){
      dragGroupName = null;
      document.querySelectorAll('.chip-tag.group-chip').forEach(chip => chip.classList.remove('dragging','drag-over-before','drag-over-after'));
      document.querySelectorAll('.note-group-title').forEach(title => title.classList.remove('dragging','drag-over-before','drag-over-after','task-drop'));
      if(groupPaletteEl){
        groupPaletteEl.classList.remove('drag-over-end');
      }
    }

    if(groupPaletteEl){
      groupPaletteEl.addEventListener('dragover', (e)=>{
        if(!dragGroupName) return;
        if(e.target !== groupPaletteEl) return;
        e.preventDefault();
        groupPaletteEl.classList.add('drag-over-end');
      });
      groupPaletteEl.addEventListener('dragleave', (e)=>{
        if(e.target === groupPaletteEl){
          groupPaletteEl.classList.remove('drag-over-end');
        }
      });
      groupPaletteEl.addEventListener('drop', (e)=>{
        if(!dragGroupName) return;
        if(e.target !== groupPaletteEl) return;
        e.preventDefault();
        e.stopPropagation();
        const from = dragGroupName || (e.dataTransfer ? e.dataTransfer.getData('text/plain') : '');
        const changed = moveItemGroupToIndex(from, state.itemGroups.length);
        clearGroupDragState();
        if(changed){
          commitGroupReorder();
        }
      });
    }

    if(btnAddGroup){
      btnAddGroup.addEventListener('click', ()=>{
        const name = (newGroupInput?.value || '').trim();
        if(!name) return;
        const added = addItemGroup(name);
        const normalized = normalizeGroupValue(name);
        if(normalized){
          setLastGroup(normalized);
        }
        newGroupInput.value='';
        if(added || normalized){
          markDirty();
        }
        if(added){
          refreshTaskViews();
        } else {
          renderGroupSelectors();
          renderGroupManager();
        }
      });
    }

    if(newGroupInput){
      newGroupInput.addEventListener('keypress', (e)=>{
        if(e.key === 'Enter'){
          e.preventDefault();
          btnAddGroup?.click();
        }
      });
    }

    if(btnQuickAddGroup){
      btnQuickAddGroup.addEventListener('click', ()=>{
        const name = prompt('New group name');
        if(!name) return;
        const added = addItemGroup(name);
        const normalized = normalizeGroupValue(name);
        if(normalized){
          setLastGroup(normalized);
        }
        if(added || normalized){
          markDirty();
        }
        if(added){
          refreshTaskViews();
        } else {
          renderGroupSelectors();
          renderGroupManager();
        }
      });
    }

    if(taskGroupSelect){
      taskGroupSelect.addEventListener('change', ()=>{
        const value = normalizeGroupValue(taskGroupSelect.value);
        if(value){
          if(!state.itemGroups.includes(value)){
            state.itemGroups.push(value);
          }
          setLastGroup(value);
        } else {
          setLastGroup('');
        }
        markDirty();
        renderGroupSelectors();
        renderGroupManager();
      });
    }

    if(newItemGroupSelect){
      newItemGroupSelect.addEventListener('change', ()=>{
        const value = normalizeGroupValue(newItemGroupSelect.value);
        if(value && state.itemGroups.includes(value)){
          setLastGroup(value);
        } else {
          setLastGroup('');
        }
        markDirty();
        renderGroupSelectors();
        renderGroupManager();
      });
    }

    // ---------- Tags ----------
    const tagPaletteEl = document.getElementById('tagPalette'); const newTagInput=document.getElementById('newTagInput');
    function renderTagPalette(selected=[]) {
      tagPaletteEl.innerHTML='';
      state.tags.forEach(t=>{
        const chip=document.createElement('button'); chip.type='button'; chip.className='chip-tag'; chip.textContent=t; chip.dataset.tag=t; if(selected.includes(t)) chip.classList.add('selected');
        chip.addEventListener('click',()=>{ chip.classList.toggle('selected'); });
        tagPaletteEl.appendChild(chip);
      });
    }
    document.getElementById('btnAddTag').addEventListener('click', ()=>{ const name=(newTagInput.value||'').trim(); if(!name) return; if(!state.tags.includes(name)) state.tags.push(name); newTagInput.value=''; markDirty(); renderTagPalette(); });

    // ---------- Tasks list / create ----------
    const taskListEl = document.getElementById('taskList');
    const checkUl = document.getElementById('checklist');
    const taskDueInput = document.getElementById('taskDueDate');
    if(taskDueInput){ taskDueInput.value = getTodayDateStr(); }
    const taskDetailsInput = document.getElementById('taskDetails');
    function getSelectedTags(){ return Array.from(tagPaletteEl.querySelectorAll('.chip-tag.selected')).map(el=>el.dataset.tag); }
    function addChecklistItem(text){ const li=document.createElement('li'); const id='c_'+Math.random().toString(36).slice(2); li.innerHTML = `<label><input type="checkbox" data-id="${id}"> <span>${esc(text)}</span></label>`; checkUl.appendChild(li); }
    document.getElementById('btnAddCheck').addEventListener('click', ()=>{ const t=document.getElementById('checkItem').value.trim(); if(!t) return; addChecklistItem(t); document.getElementById('checkItem').value=''; });

    document.getElementById('btnAddTask').addEventListener('click', ()=>{
      const title=(document.getElementById('taskTitle').value||'').trim(); if(!title){ alert('Enter a title'); return; }
      const status=document.getElementById('taskStatus').value;
      const priority=Number(document.getElementById('taskPriority').value)||2;
      const dueVal = taskDueInput && taskDueInput.value ? taskDueInput.value : getTodayDateStr();
      let dueDate = parseDateInput(dueVal);
      if(dueDate == null){ dueDate = getTodayTimestamp(); }
      const details = taskDetailsInput ? taskDetailsInput.value.trim() : '';
      const groupValue = taskGroupSelect ? normalizeGroupValue(taskGroupSelect.value) : getLastGroup();
      if(groupValue && !state.itemGroups.includes(groupValue)){
        state.itemGroups.push(groupValue);
      }
      const tags=getSelectedTags();
      const checklist = Array.from(checkUl.querySelectorAll('input[type="checkbox"]')).map(cb=>({ t: cb.nextElementSibling.textContent, done: cb.checked }));
      const task={ id:Date.now().toString(36)+Math.random().toString(36).slice(2), title, status, priority, tags, checklist, createdAt:Date.now(), dueDate, startTime:null, details, group: groupValue };
      state.tasks.unshift(task);
      // reset form
      document.getElementById('taskTitle').value='';
      if(taskDueInput) taskDueInput.value = getTodayDateStr();
      if(taskDetailsInput) taskDetailsInput.value = '';
      document.getElementById('checkItem').value='';
      checkUl.innerHTML='';
      tagPaletteEl.querySelectorAll('.chip-tag.selected').forEach(x=>x.classList.remove('selected'));
      if(taskGroupSelect){ taskGroupSelect.value = groupValue || ''; }
      setLastGroup(groupValue);
      markDirty();
      refreshTaskViews();
    });
    document.getElementById('btnClearAll').addEventListener('click', ()=>{ if(confirm('Clear ALL tasks?')){ state.tasks=[]; state.manualOrder=[]; markDirty(); renderNotesList(); refreshTaskShellViews(); }});

    const titleize=(str)=>{
      return String(str||'')
        .replace(/[-_]+/g,' ')
        .replace(/\b([a-z])/g,(m,chr)=>chr.toUpperCase())
        || '';
    };

    function getKanbanGroupingValue(){
      const raw = state?.settings?.kanbanGrouping;
      return KANBAN_GROUP_OPTIONS.includes(raw) ? raw : 'tab';
    }

    function buildKanbanGrouping(grouping){
      const tasks = Array.isArray(state.tasks) ? state.tasks : [];
      if(grouping==='priority'){
        const lanes=[
          {key:'p1', name:'P1'},
          {key:'p2', name:'P2'},
          {key:'p3', name:'P3'},
          {key:'p4', name:'P4'},
          {key:'p5', name:'P5+'}
        ];
        const clampPriority=(value)=>{
          const num=Number(value);
          if(!Number.isFinite(num) || num<1) return 5;
          return Math.min(Math.floor(num),5);
        };
        return {
          lanes,
          getKey:(task)=>`p${clampPriority(task?.priority)}`,
          apply:(task,laneKey)=>{
            const target=clampPriority(laneKey?.slice(1));
            if(task.priority===target) return false;
            task.priority=target;
            return true;
          }
        };
      }
      if(grouping==='category'){
        const freq=new Map();
        tasks.forEach(task=>{
          const firstTag=Array.isArray(task?.tags)? task.tags.find(tag=>tag && tag.trim()):null;
          if(firstTag){
            const key=firstTag.trim();
            freq.set(key,(freq.get(key)||0)+1);
          }
        });
        const sorted=Array.from(freq.entries()).sort((a,b)=>{
          if(b[1]!==a[1]) return b[1]-a[1];
          return a[0].localeCompare(b[0]);
        });
        const MAX_TAG_COLUMNS=3;
        const primaryTags=sorted.slice(0,MAX_TAG_COLUMNS).map(([tag])=>tag);
        const lanes=[];
        primaryTags.forEach(tag=>{
          lanes.push({key:`tag:${tag}`, name:tag});
        });
        const hasUntagged=tasks.some(task=>!Array.isArray(task?.tags) || task.tags.length===0);
        const hasOther=tasks.some(task=>{
          const firstTag=Array.isArray(task?.tags)? task.tags.find(tag=>tag && tag.trim()):null;
          if(!firstTag) return false;
          return !primaryTags.includes(firstTag);
        });
        if(hasUntagged && lanes.length<5){
          lanes.push({key:'tag:__untagged', name:'Untagged'});
        }
        if(hasOther && lanes.length<5){
          lanes.push({key:'tag:__other', name:'Other'});
        }
        if(!lanes.some(l=>l.key==='tag:__untagged') && lanes.length<5){
          const otherIndex=lanes.findIndex(l=>l.key==='tag:__other');
          const insertIndex = otherIndex>=0 ? otherIndex : lanes.length;
          lanes.splice(insertIndex,0,{key:'tag:__untagged', name:'Untagged'});
        }
        if(!lanes.some(l=>l.key==='tag:__other')){
          if(lanes.length<5){
            lanes.push({key:'tag:__other', name:'Other'});
          } else if(lanes.length){
            lanes[lanes.length-1]={key:'tag:__other', name:'Other'};
          } else {
            lanes.push({key:'tag:__other', name:'Other'});
          }
        }
        if(lanes.length>5){
          lanes.length=5;
        }
        const validKeys=new Set(lanes.map(l=>l.key));
        const fallbackKey=lanes[lanes.length-1]?.key||'tag:__other';
        return {
          lanes,
          getKey:(task)=>{
            const firstTag=Array.isArray(task?.tags)? task.tags.find(tag=>tag && tag.trim()):null;
            if(!firstTag) return validKeys.has('tag:__untagged')?'tag:__untagged':fallbackKey;
            const laneKey=`tag:${firstTag}`;
            return validKeys.has(laneKey)? laneKey : (validKeys.has('tag:__other')?'tag:__other':fallbackKey);
          },
          apply:(task,laneKey)=>{
            if(!validKeys.has(laneKey)) return false;
            if(laneKey==='tag:__untagged'){
              if(!task.tags || !task.tags.length) return false;
              task.tags=[];
              return true;
            }
            if(laneKey==='tag:__other'){
              if(!state.tags.includes('Other')) state.tags.push('Other');
              if(Array.isArray(task.tags) && task.tags.length===1 && task.tags[0]==='Other') return false;
              task.tags=['Other'];
              return true;
            }
            const tagName=laneKey.slice(4);
            if(!state.tags.includes(tagName)) state.tags.push(tagName);
            if(Array.isArray(task.tags) && task.tags.length===1 && task.tags[0]===tagName) return false;
            task.tags=[tagName];
            return true;
          }
        };
      }
      if(grouping==='date'){
        const lanes=[
          {key:'late', name:'Late'},
          {key:'today', name:'Today'},
          {key:'week', name:'This Week'},
          {key:'next', name:'Next Week'},
          {key:'future', name:'Future'}
        ];
        const dayMs=24*60*60*1000;
        const todayTs=getTodayTimestamp();
        const startOfToday=todayTs;
        const startOfTomorrow=startOfToday+dayMs;
        const endOfWeekExclusive=startOfToday+7*dayMs;
        const endOfNextWeekExclusive=startOfToday+14*dayMs;
        const laneKeyForDate=(ts)=>{
          if(!Number.isFinite(ts)) return 'future';
          if(ts < startOfToday) return 'late';
          if(ts < startOfTomorrow) return 'today';
          if(ts < endOfWeekExclusive) return 'week';
          if(ts < endOfNextWeekExclusive) return 'next';
          return 'future';
        };
        return {
          lanes,
          getKey:(task)=>laneKeyForDate(Number(task?.dueDate)),
          apply:(task,laneKey)=>{
            const setters={
              late:startOfToday-dayMs,
              today:startOfToday,
              week:startOfToday+2*dayMs,
              next:endOfWeekExclusive+dayMs,
              future:endOfNextWeekExclusive+dayMs
            };
            const target=setters[laneKey];
            if(typeof target!=='number') return false;
            if(task.dueDate===target) return false;
            task.dueDate=target;
            return true;
          }
        };
      }
      const base=[
        {key:'backlog', name:'Backlog'},
        {key:'ready', name:'Ready'},
        {key:'doing', name:'Doing'},
        {key:'review', name:'Review'},
        {key:'done', name:'Done'}
      ];
      const seen=new Set(base.map(l=>l.key));
      tasks.forEach(task=>{
        const status=String(task?.status||'').trim().toLowerCase();
        if(status && !seen.has(status) && base.length<5){
          base.push({key:status, name:titleize(status)||'Custom'});
          seen.add(status);
        }
      });
      const lanes=base.slice(0,5);
      const validKeys=new Set(lanes.map(l=>l.key));
      const fallback=lanes[0]?.key||'backlog';
      return {
        lanes,
        getKey:(task)=>{
          const status=String(task?.status||'').trim().toLowerCase();
          return validKeys.has(status)? status : fallback;
        },
        apply:(task,laneKey)=>{
          if(!validKeys.has(laneKey)) return false;
          return applyTaskStatus(task, laneKey);
        }
      };
    }

    function renderTasks(){
      document.getElementById('taskCount').textContent = `${state.tasks.length} task${state.tasks.length===1?'':'s'}`;
      taskListEl.innerHTML='';
      // Sort tasks: incomplete first, then completed; sort by due date ascending then createdAt
      const tasksSorted = state.tasks.slice().sort(compareTaskDisplayOrder);
      tasksSorted.forEach(t=>{
        const card=document.createElement('div'); card.className='task-card';
        card.dataset.taskId = t.id;
        const top=document.createElement('div'); top.style.display='flex'; top.style.justifyContent='space-between'; top.style.alignItems='center'; top.style.gap='8px'; top.style.minWidth='0';
        const title=document.createElement('div'); title.className='task-title'; applyTruncatedTitle(title, t.title);
        top.appendChild(title);
        const meta=document.createElement('div'); meta.className='subtle';
        let metaText = `${t.status} • P${t.priority}`;
        if(t.group){
          metaText += ` • ${t.group}`;
        }
        if(t.dueDate){
          metaText += ' • Due ' + formatDate(t.dueDate);
          if(t.startTime){
            const dt=new Date(t.startTime);
            const hh=dt.getHours().toString().padStart(2,'0');
            const mm=dt.getMinutes().toString().padStart(2,'0');
            metaText += ' ' + hh + ':' + mm;
          }
        }
        meta.textContent = metaText; top.appendChild(meta);
        card.appendChild(top);
        if(t.tags && t.tags.length){ const row=document.createElement('div'); row.className='tag-chips'; row.style.marginTop='6px'; t.tags.forEach(tag=>{ const pill=document.createElement('span'); pill.className='pill'; pill.textContent=tag; row.appendChild(pill); }); card.appendChild(row); }
        if(t.details){ const detail=document.createElement('div'); detail.className='task-details'; detail.textContent=t.details; card.appendChild(detail); }
        if(t.checklist && t.checklist.length){ const ul=document.createElement('ul'); ul.className='checklist'; t.checklist.forEach((c,i)=>{ const li=document.createElement('li'); li.innerHTML=`<label><input type="checkbox" ${c.done?'checked':''}> ${esc(c.t)}</label>`; li.querySelector('input').addEventListener('change', (e)=>{ c.done=e.target.checked; markDirty(); renderNotesList(); }); ul.appendChild(li); }); card.appendChild(ul); }
        // Clicking on the card (except buttons/selects) opens the edit modal for this task
        card.addEventListener('click', (ev) => {
          // don't trigger if clicking delete button or status select
          if(ev.target.closest('button') || ev.target.closest('select')) return;
          openTaskModalForId(t.id);
        });
        const bar=document.createElement('div'); bar.className='toolbar';
        const del=document.createElement('button'); del.className='btn'; del.textContent='Delete';
        del.addEventListener('click', ()=>{
          deleteTask(t);
        });
        const mv=document.createElement('select'); mv.className='btn'; ['backlog','doing','done'].forEach(s=>{ const o=document.createElement('option'); o.value=s; o.textContent=s; if(s===t.status) o.selected=true; mv.appendChild(o); }); mv.addEventListener('change', e=>{ const changed=applyTaskStatus(t, e.target.value); if(changed){ markDirty(); } renderKanban(); renderGrid(); renderTasks(); renderCalendar(); renderNotesList(); if(selectedDate) renderDay(selectedDate); });
        bar.appendChild(mv); bar.appendChild(del); card.appendChild(bar);
        taskListEl.appendChild(card);
      });
    }

    // ---------- Kanban (drag & drop) ----------
    function renderKanban(){
      const root=document.getElementById('kanban');
      if(!root) return;
      root.innerHTML='';
      const grouping=getKanbanGroupingValue();
      const groupingSelect=document.getElementById('kanbanGrouping');
      if(groupingSelect && groupingSelect.value!==grouping){
        groupingSelect.value=grouping;
      }
      const config=buildKanbanGrouping(grouping);
      const lanes=config.lanes||[];
      if(!lanes.length){
        root.innerHTML='<div class="subtle">No lanes available</div>';
        return;
      }
      const laneTaskMap=new Map();
      lanes.forEach(l=> laneTaskMap.set(l.key, []));
      const fallbackKey=lanes[0]?.key||null;
      (state.tasks||[]).forEach(task=>{
        let laneKey=config.getKey? config.getKey(task):fallbackKey;
        if(!laneTaskMap.has(laneKey)) laneKey=fallbackKey;
        if(laneKey && laneTaskMap.has(laneKey)){
          laneTaskMap.get(laneKey).push(task);
        }
      });
      lanes.forEach(l=>{
        const col=document.createElement('div'); col.className='col'; col.dataset.lane=l.key;
        const head=document.createElement('div'); head.className='col-head'; head.textContent = `${l.name}`; col.appendChild(head);
        const body=document.createElement('div'); body.className='col-body';
        body.addEventListener('dragover',(e)=>{ e.preventDefault(); body.classList.add('drag-over'); });
        body.addEventListener('dragleave',()=> body.classList.remove('drag-over'));
        body.addEventListener('drop',(e)=>{
          e.preventDefault();
          body.classList.remove('drag-over');
          const id=e.dataTransfer.getData('text/plain');
          const t=state.tasks.find(x=>x.id===id);
          if(t){
            const changed=config.apply? config.apply(t,l.key):false;
            if(changed){
              markDirty();
            }
            renderKanban();
            renderGrid();
            renderTasks();
            renderTagPalette();
            renderNotesList();
            renderCalendar();
            if(selectedDate) renderDay(selectedDate);
          }
        });
        const laneTasks = (laneTaskMap.get(l.key)||[]).slice().sort(compareTaskDisplayOrder);
        laneTasks.forEach(t=>{
          const c=document.createElement('div');
          c.className='kb-card';
          c.dataset.taskId = t.id;
          c.draggable=true;
          c.addEventListener('dragstart',(e)=>{ e.dataTransfer.setData('text/plain', t.id); });
          const titleEl=document.createElement('div');
          titleEl.className='kb-card-title';
          applyTruncatedTitle(titleEl, t.title);
          const metaEl=document.createElement('div');
          metaEl.className='subtle';
          const parts=[];
          const priorityLabel = (t.priority!=null && t.priority!=='') ? `P${t.priority}` : 'P?';
          parts.push(priorityLabel);
          if(grouping!=='tab' && t.status){ parts.push(titleize(t.status)||t.status); }
          if(t.tags?.length) parts.push(t.tags.join(', '));
          if(t.group) parts.push(t.group);
          if(t.dueDate) parts.push('Due '+formatDate(t.dueDate));
          metaEl.textContent = parts.filter(Boolean).join(' • ');
          c.appendChild(titleEl);
          c.appendChild(metaEl);
          if(t.details){ const detailEl=document.createElement('div'); detailEl.className='kanban-detail'; detailEl.textContent=t.details; c.appendChild(detailEl); }
          if(t.details) c.title = t.details;
          // Click opens edit modal
          c.addEventListener('click', (ev) => {
            ev.stopPropagation();
            openTaskModalForId(t.id);
          });
          body.appendChild(c);
        });
        col.appendChild(body); root.appendChild(col);
      });
    }

    // ---------- Table (grid with keyboard navigation) ----------
    let sortKey='createdAt', sortDir='desc';
    function renderGrid(){
      const tbody=document.getElementById('gridBody'); tbody.innerHTML='';
      const items = state.tasks.slice().sort((a,b)=>{
        const doneA = String(a.status||'').toLowerCase()==='done';
        const doneB = String(b.status||'').toLowerCase()==='done';
        if(doneA!==doneB) return doneA?1:-1;
        let av=a[sortKey], bv=b[sortKey];
        if(sortKey==='tags'){ av=(a.tags||[]).join(','); bv=(b.tags||[]).join(','); }
        if(sortKey==='createdAt'){ av=a.createdAt||0; bv=b.createdAt||0; }
        if(sortKey==='dueDate'){ av=a.dueDate||0; bv=b.dueDate||0; }
        if(sortKey==='priority'){ av=Number(av)||0; bv=Number(bv)||0; }
        av = typeof av==='string'? av.toLowerCase() : av; bv = typeof bv==='string'? bv.toLowerCase() : bv;
        const cmp = av>bv?1:av<bv?-1:0;
        return sortDir==='asc' ? cmp : -cmp;
      });
      items.forEach((t,rowIdx)=>{
        const tr=document.createElement('tr'); tr.dataset.id=t.id; tr.dataset.taskId = t.id;
        const cols=[
          {k:'title', v:t.title},
          {k:'status', v:t.status},
          {k:'group', v:t.group || ''},
          {k:'priority', v:'P'+(t.priority||'')},
          {k:'dueDate', v: t.dueDate ? formatDate(t.dueDate) : ''},
          {k:'tags', v:(t.tags||[]).join(', ')},
          {k:'details', v:t.details||''},
          {k:'createdAt', v:new Date(t.createdAt||Date.now()).toLocaleString()}
        ];
        cols.forEach((c,colIdx)=>{
          const td=document.createElement('td');
          const ed = (c.k==='createdAt')? false : true; // createdAt is read-only
          const span=document.createElement('span'); span.className='cell'; span.tabIndex=0; span.dataset.row=rowIdx; span.dataset.col=colIdx; span.dataset.field=c.k; span.textContent=c.v; if(ed) span.setAttribute('contenteditable','true');
          span.addEventListener('keydown', (e)=>handleCellKey(e, span));
          span.addEventListener('blur', ()=>commitCell(span, t));
          td.appendChild(span); tr.appendChild(td);
        });
        tbody.appendChild(tr);
        // Table view is intended for inline editing only, so avoid launching the modal here.
      });
      // Header sort indicators
      document.querySelectorAll('#taskTable thead th').forEach(th=>{ th.classList.remove('sort-asc','sort-desc'); if(th.dataset.key===sortKey) th.classList.add(sortDir==='asc'?'sort-asc':'sort-desc'); });
    }
    function commitCell(cell, task){
      const field = cell.dataset.field;
      const raw = cell.textContent.trim();
      if(!field) return;
      if(field === 'priority'){
        const p = String(raw).replace(/^[pP]/, '');
        task.priority = Number(p) || 2;
      } else if(field === 'tags'){
        task.tags = raw ? raw.split(',').map(t => t.trim()).filter(Boolean) : [];
      } else if(field === 'status'){
        applyTaskStatus(task, raw || 'backlog');
      } else if(field === 'group'){
        const normalized = normalizeGroupValue(raw);
        const changed = setTaskGroup(task, normalized);
        if(changed){
          setLastGroup(normalized);
          if(!task.fromNotes){
            moveManualTaskToGroupEnd(task.id, normalized);
          }
        }
      } else if(field === 'title'){
        task.title = raw || '(untitled)';
      } else if(field === 'dueDate'){
        if(raw){
          const ts = parseDateInput(raw);
          task.dueDate = ts != null ? ts : null;
        } else {
          task.dueDate = null;
        }
      } else if(field === 'details'){
        task.details = raw;
      }
      markDirty();
      renderGroupSelectors();
      renderGroupManager();
      renderKanban();
      renderTasks();
      renderCalendar();
      if(selectedDate) renderDay(selectedDate);
    }
    function handleCellKey(e, cell){ const key=e.key.toLowerCase(); const row=parseInt(cell.dataset.row,10); const col=parseInt(cell.dataset.col,10); const table=document.getElementById('gridBody'); const maxR=table.rows.length-1; const maxC=table.rows[0]? table.rows[0].cells.length-1:0; const move=(r,c)=>{ const next = table.querySelector(`span.cell[data-row="${r}"][data-col="${c}"]`); if(next){ e.preventDefault(); next.focus(); selectAll(next); } };
      if(key==='arrowright'){ move(row, Math.min(maxC, col+1)); }
      else if(key==='arrowleft'){ move(row, Math.max(0, col-1)); }
      else if(key==='arrowdown'){ move(Math.min(maxR,row+1), col); }
      else if(key==='arrowup'){ move(Math.max(0,row-1), col); }
      else if(key==='tab'){ move(row, Math.min(maxC, col+(e.shiftKey?-1:1))); }
      else if(key==='enter'){ move(Math.min(maxR,row+1), col); }
    }
    function selectAll(el){ const range=document.createRange(); range.selectNodeContents(el); const sel=window.getSelection(); sel.removeAllRanges(); sel.addRange(range); }
    document.querySelectorAll('#taskTable thead th').forEach(th=> th.addEventListener('click', ()=>{ const k=th.dataset.key; if(k===sortKey) sortDir = (sortDir==='asc'?'desc':'asc'); else { sortKey=k; sortDir='asc'; } renderGrid(); }) );

    // ---------- JSON Import/Export ----------
    document.getElementById('btnExportJson').addEventListener('click', ()=>{ const payload = JSON.stringify(state, null, 2); const blob=new Blob([payload], {type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='n6-notes-tasks.json'; a.click(); URL.revokeObjectURL(url); });
    document.getElementById('btnImportJson').addEventListener('click', ()=> document.getElementById('importFile').click());
    document.getElementById('importFile').addEventListener('change', async (e)=>{ const f=e.target.files[0]; if(!f) return; const text = await f.text(); try{ const data=JSON.parse(text); if(!data||typeof data!=='object') throw new Error('Invalid'); state = Object.assign(defaultState(), data); markDirty(); renderAll(); }catch(err){ alert('Invalid JSON'); } e.target.value=''; });

    // ---------- Modal editing for note items ----------
    const taskModal = document.getElementById('taskModal');
    const modalTitleInput = document.getElementById('modalTitleInput');
    const modalStatusSelect = document.getElementById('modalStatusSelect');
    const modalPrioritySelect = document.getElementById('modalPrioritySelect');
    const modalDueDate = document.getElementById('modalDueDate');
    const modalTagContainer = document.getElementById('modalTagContainer');
    const modalNewTagInput = document.getElementById('modalNewTagInput');
    const modalAddTag = document.getElementById('modalAddTag');
    const modalSaveBtn = document.getElementById('modalSaveBtn');
    const modalCancelBtn = document.getElementById('modalCancelBtn');
    const modalCompleteToggle = document.getElementById('modalCompleteToggle');
    const modalDetails = document.getElementById('modalDetails');
    const modalChecklist = document.getElementById('modalChecklist');
    const modalCheckInput = document.getElementById('modalCheckInput');
    const modalAddCheckBtn = document.getElementById('modalAddCheck');
    let modalChecklistData = [];

    function renderModalChecklist(){
      if(!modalChecklist) return;
      modalChecklist.innerHTML = '';
      modalChecklistData.forEach((item, index) => {
        const li = document.createElement('li');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = !!item.done;
        checkbox.addEventListener('change', (e) => {
          modalChecklistData[index].done = e.target.checked;
        });
        const textInput = document.createElement('input');
        textInput.type = 'text';
        textInput.placeholder = 'Checklist item';
        textInput.value = item.t || '';
        textInput.addEventListener('input', (e) => {
          modalChecklistData[index].t = e.target.value;
        });
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'modal-check-remove';
        removeBtn.textContent = '✕';
        removeBtn.setAttribute('aria-label', 'Remove checklist item');
        removeBtn.addEventListener('click', () => {
          modalChecklistData.splice(index, 1);
          renderModalChecklist();
        });
        li.appendChild(checkbox);
        li.appendChild(textInput);
        li.appendChild(removeBtn);
        modalChecklist.appendChild(li);
      });
    }

    if(modalAddCheckBtn){
      modalAddCheckBtn.addEventListener('click', () => {
        const text = (modalCheckInput?.value || '').trim();
        if(!text) return;
        modalChecklistData.push({ t: text, done: false });
        if(modalCheckInput){ modalCheckInput.value = ''; }
        renderModalChecklist();
      });
    }
    if(modalCheckInput){
      modalCheckInput.addEventListener('keypress', (e) => {
        if(e.key === 'Enter'){
          e.preventDefault();
          modalAddCheckBtn?.click();
        }
      });
    }
    let currentModalTask = null;
    function populateTaskModal(task){
      if(!task) return;
      currentModalTask = task;
      if(!Array.isArray(task.tags)) task.tags = [];
      if(modalTitleInput){
        modalTitleInput.value = task.title || '';
        modalTitleInput.focus();
        modalTitleInput.select();
      }
      const statusVal = normalizeStatusValue(task.status);
      const fallbackStatus = statusVal === 'done' ? ensureLastActiveStatus(task) : statusVal;
      modalStatusSelect.disabled = false;
      modalStatusSelect.value = statusVal;
      modalStatusSelect.dataset.prevStatus = fallbackStatus;
      if(modalCompleteToggle){
        modalCompleteToggle.checked = statusVal === 'done';
        modalStatusSelect.disabled = modalCompleteToggle.checked;
        if(modalCompleteToggle.checked){
          modalStatusSelect.value = 'done';
        }
      }
      modalPrioritySelect.value = String(task.priority || 2);
      modalTagContainer.innerHTML = '';
      const seen = new Set();
      const combined = [];
      (state.tags || []).forEach(tag => {
        if(tag && !seen.has(tag)){ seen.add(tag); combined.push(tag); }
      });
      (task.tags || []).forEach(tag => {
        if(tag && !seen.has(tag)){ seen.add(tag); combined.push(tag); }
      });
      combined.forEach(tag => {
        const chip=document.createElement('button');
        chip.type='button';
        chip.className='chip-tag';
        chip.textContent=tag;
        chip.dataset.tag=tag;
        if(task.tags && task.tags.includes(tag)) chip.classList.add('selected');
        chip.addEventListener('click', () => { chip.classList.toggle('selected'); });
        modalTagContainer.appendChild(chip);
      });
      modalNewTagInput.value = '';
      if(modalDueDate){
        modalDueDate.value = task.dueDate ? formatDate(task.dueDate) : '';
      }
      if(modalGroupSelect){
        modalGroupSelect.dataset.selected = normalizeGroupValue(task.group);
        renderGroupSelectors();
        modalGroupSelect.value = normalizeGroupValue(task.group) || '';
      }
      if(modalDetails){
        modalDetails.value = task.details || '';
      }
      if(modalChecklist){
        modalChecklistData = Array.isArray(task.checklist) ? task.checklist.map(item => ({ t: item.t || '', done: !!item.done })) : [];
        renderModalChecklist();
      }
      if(modalCheckInput){
        modalCheckInput.value = '';
      }
      taskModal.style.display = 'flex';
    }

    function openTaskModalByKey(noteKey){
      const task = state.tasks.find(t => t.noteKey === noteKey);
      if(!task) return;
      populateTaskModal(task);
    }

    // Open the task editing modal for a given task by its id (used outside of notes)
    function openTaskModalForId(taskId){
      const task = state.tasks.find(t => t.id === taskId);
      if(!task) return;
      populateTaskModal(task);
    }

    if(modalCompleteToggle){
      modalCompleteToggle.addEventListener('change', () => {
        if(modalCompleteToggle.checked){
          const current = normalizeStatusValue(modalStatusSelect.value || (currentModalTask ? currentModalTask.status : 'backlog'));
          const fallback = current === 'done' && currentModalTask ? ensureLastActiveStatus(currentModalTask) : current;
          modalStatusSelect.dataset.prevStatus = fallback;
          modalStatusSelect.value = 'done';
          modalStatusSelect.disabled = true;
        } else {
          modalStatusSelect.disabled = false;
          const prev = normalizeStatusValue(modalStatusSelect.dataset.prevStatus || (currentModalTask ? ensureLastActiveStatus(currentModalTask) : 'backlog'));
          modalStatusSelect.value = prev;
        }
      });
    }
    modalStatusSelect.addEventListener('change', () => {
      const normalized = normalizeStatusValue(modalStatusSelect.value);
      if(normalized === 'done'){
        const fallback = currentModalTask ? ensureLastActiveStatus(currentModalTask) : 'backlog';
        modalStatusSelect.dataset.prevStatus = fallback;
        if(modalCompleteToggle){
          modalCompleteToggle.checked = true;
          modalStatusSelect.disabled = true;
        }
      } else {
        modalStatusSelect.dataset.prevStatus = normalized;
        if(modalCompleteToggle){
          modalCompleteToggle.checked = false;
          modalStatusSelect.disabled = false;
        }
      }
    });
    function closeTaskModal(){
      taskModal.style.display = 'none';
      currentModalTask = null;
      modalChecklistData = [];
      if(modalChecklist){ modalChecklist.innerHTML = ''; }
      if(modalCheckInput){ modalCheckInput.value = ''; }
      if(modalTitleInput){ modalTitleInput.value = ''; }
      if(modalGroupSelect){ modalGroupSelect.dataset.selected = ''; }
    }
    modalSaveBtn.addEventListener('click', () => {
      if(!currentModalTask){ closeTaskModal(); return; }
      if(modalTitleInput){
        const title = modalTitleInput.value.trim();
        currentModalTask.title = title || '(untitled)';
      }
      const isComplete = modalCompleteToggle && modalCompleteToggle.checked;
      const statusChoice = normalizeStatusValue(modalStatusSelect.value);
      if(isComplete){
        setTaskCompletion(currentModalTask, true);
      } else {
        applyTaskStatus(currentModalTask, statusChoice);
      }
      modalStatusSelect.dataset.prevStatus = ensureLastActiveStatus(currentModalTask);
      currentModalTask.priority = Number(modalPrioritySelect.value) || 2;
      const selectedTags = Array.from(modalTagContainer.querySelectorAll('.chip-tag.selected')).map(el => el.dataset.tag);
      currentModalTask.tags = selectedTags;
      if(modalDetails){
        currentModalTask.details = modalDetails.value.trim();
      }
      if(modalDueDate){
        currentModalTask.dueDate = modalDueDate.value ? parseDateInput(modalDueDate.value) : null;
      }
      if(modalChecklist){
        const cleaned = modalChecklistData
          .map(item => ({ t: (item.t || '').trim(), done: !!item.done }))
          .filter(item => item.t);
        currentModalTask.checklist = cleaned;
      }
      if(modalGroupSelect){
        const selectedGroup = normalizeGroupValue(modalGroupSelect.value || '');
        const changedGroup = setTaskGroup(currentModalTask, selectedGroup);
        if(changedGroup){
          setLastGroup(selectedGroup);
          if(!currentModalTask.fromNotes){
            moveManualTaskToGroupEnd(currentModalTask.id, selectedGroup);
          }
        }
      }
      const newName = (modalNewTagInput.value || '').trim();
      if(newName){
        if(!state.tags.includes(newName)){
          state.tags.push(newName);
        }
        if(!currentModalTask.tags.includes(newName)){
          currentModalTask.tags.push(newName);
        }
      }
      modalNewTagInput.value = '';
      markDirty();
      renderTagPalette();
      renderNotesList();
      refreshTaskShellViews();
      closeTaskModal();
    });
    modalCancelBtn.addEventListener('click', () => {
      closeTaskModal();
    });
    // optional: clicking outside card closes
    taskModal.addEventListener('click', (e) => {
      if(e.target === taskModal){ closeTaskModal(); }
    });

    // Add new tag inside modal
    modalAddTag.addEventListener('click', () => {
      const name = (modalNewTagInput.value || '').trim();
      if(!name) return;
      // Add to global tags if not present
      if(!state.tags.includes(name)){
        state.tags.push(name);
      }
      // Add to current task tags if editing an existing task
      if(currentModalTask){
        if(!currentModalTask.tags.includes(name)){
          currentModalTask.tags.push(name);
        }
      }
      // Create chip in modal and mark selected
      const chip = document.createElement('button');
      chip.type = 'button';
      chip.className = 'chip-tag selected';
      chip.textContent = name;
      chip.dataset.tag = name;
      chip.addEventListener('click', () => {
        chip.classList.toggle('selected');
      });
      modalTagContainer.appendChild(chip);
      modalNewTagInput.value = '';
    });

    // ---------- SharePoint scaffolding (commented for future plug‑and‑play) ----------
    /*
    // Example: enable, then set SP_LIST_PATH / SP_LIBRARY_PATH and call pushToList()/uploadToLibrary()
    const SP_LIST_PATH = '/sites/YourSite/Lists/Tasks';
    const SP_LIBRARY_PATH = '/sites/YourSite/Shared Documents';
    async function spRequest(path, opts={}){
      const web = (window._spPageContextInfo && _spPageContextInfo.webAbsoluteUrl) || location.origin; // must be same-origin
      const url = path.startsWith('http')? path : web.replace(/\/$/,'') + '/' + path.replace(/^\//,'');
      const res = await fetch(url, Object.assign({ credentials:'include', headers:{ 'Accept':'application/json;odata=nometadata' }}, opts));
      if(!res.ok){ const t=await res.text().catch(()=> ''); throw new Error(`${opts.method||'GET'} ${path} -> ${res.status}: ${t}`); }
      const ct=res.headers.get('Content-Type')||''; return ct.includes('json')? res.json(): res.text();
    }
    async function pushToList(){ /* map state.tasks to list items here *-/ }
    async function uploadToLibrary(){ /* upload a JSON snapshot to a library here *-/ }
    */

    // ---------- Calendar & Day (My Day) ----------
    // Track the currently displayed month for the calendar. Always represents the first day of that month.
    let calendarMonth = new Date();
    calendarMonth.setDate(1);
    let daySidebarMonth = new Date();
    daySidebarMonth.setDate(1);

    function zeroPad(n){ return String(n).padStart(2, '0'); }

    // Render the calendar view for the current month. Populates the calendar grid with day cells,
    // shows tasks with due dates on their corresponding day, enables drag-and-drop to reschedule tasks,
    // and updates the month label.
    function renderCalendar(){
      const grid = document.getElementById('calendarGrid');
      if(!grid) return;
      grid.innerHTML = '';
      const today = new Date(); today.setHours(0,0,0,0);
      // Day of week header
      const dayNames = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
      dayNames.forEach(name => {
        const div = document.createElement('div');
        div.className = 'day-of-week';
        div.textContent = name;
        grid.appendChild(div);
      });
      const year = calendarMonth.getFullYear();
      const month = calendarMonth.getMonth();
      const first = new Date(year, month, 1);
      const firstDay = first.getDay(); // 0=Sun
      const daysInMonth = new Date(year, month + 1, 0).getDate();
      const prevMonthDays = new Date(year, month, 0).getDate();
      // Build 42 cells (6 weeks)
      for(let i=0;i<42;i++){
        const cell = document.createElement('div');
        cell.className = 'calendar-cell';
        let dateNum, cellMonth, cellYear;
        if(i < firstDay){
          // Previous month
          dateNum = prevMonthDays - firstDay + 1 + i;
          cellMonth = month - 1;
          cellYear = year;
          if(cellMonth < 0){ cellMonth = 11; cellYear--; }
          cell.classList.add('out-month');
        } else if(i >= firstDay + daysInMonth){
          // Next month
          dateNum = i - (firstDay + daysInMonth) + 1;
          cellMonth = month + 1;
          cellYear = year;
          if(cellMonth > 11){ cellMonth = 0; cellYear++; }
          cell.classList.add('out-month');
        } else {
          // Current month
          dateNum = i - firstDay + 1;
          cellMonth = month;
          cellYear = year;
        }
        const cellDate = new Date(cellYear, cellMonth, dateNum);
        const dateStr = cellYear + '-' + zeroPad(cellMonth+1) + '-' + zeroPad(dateNum);
        if(isSameDate(cellDate, today)) cell.classList.add('today');
        if(selectedDate && selectedDate === dateStr) cell.classList.add('selected');
        // Date number label
        const dateNumEl = document.createElement('div');
        dateNumEl.className = 'date-num';
        dateNumEl.textContent = dateNum;
        cell.appendChild(dateNumEl);
        // Tasks due on this date
        const tasksForDate = state.tasks.filter(t => {
          if(!t.dueDate) return false;
          const dt = new Date(t.dueDate);
          return dt.getFullYear() === cellYear && dt.getMonth() === cellMonth && dt.getDate() === dateNum;
        });
        // Sort tasks by startTime then priority then createdAt
        tasksForDate.sort((a,b) => {
          const aStart = a.startTime ?? Infinity;
          const bStart = b.startTime ?? Infinity;
          if(aStart !== bStart) return aStart - bStart;
          if(a.priority !== b.priority) return a.priority - b.priority;
          return (a.createdAt||0) - (b.createdAt||0);
        });
        tasksForDate.forEach(t => {
          const taskDiv = document.createElement('div');
          taskDiv.className = 'calendar-task';
          taskDiv.dataset.taskId = t.id;
          let displayTitle = t.title || '';
          if(t.startTime){
            const dt = new Date(t.startTime);
            const hh = dt.getHours().toString().padStart(2,'0');
            const mm = dt.getMinutes().toString().padStart(2,'0');
            displayTitle = displayTitle ? `${displayTitle} (${hh}:${mm})` : `(${hh}:${mm})`;
          }
          applyTruncatedTitle(taskDiv, displayTitle, { extraTooltip: t.details, ellipsisReservePercent: 0.18 });
          taskDiv.draggable = true;
          taskDiv.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', t.id);
          });
          // clicking a calendar task opens the edit modal
          taskDiv.addEventListener('click', (ev) => {
            ev.stopPropagation();
            openTaskModalForId(t.id);
          });
          cell.appendChild(taskDiv);
        });
        // Click to open day view for this date
        cell.addEventListener('click', (e) => {
          // Only react if clicking cell or date label (not tasks)
          if(e.target !== cell && e.target !== dateNumEl) return;
          selectedDate = dateStr;
          calendarMonth = new Date(cellYear, cellMonth, 1);
          daySidebarMonth = new Date(cellYear, cellMonth, 1);
          renderCalendar();
          showView('day');
        });
        // Drag-over and drop behaviour
        cell.addEventListener('dragover', (e) => {
          e.preventDefault();
          cell.classList.add('drag-over');
        });
        cell.addEventListener('dragleave', () => {
          cell.classList.remove('drag-over');
        });
        cell.addEventListener('drop', (e) => {
          e.preventDefault();
          const id = e.dataTransfer.getData('text/plain');
          const task = state.tasks.find(x => x.id === id);
          if(task){
            // Determine new due date/time
            const parts = dateStr.split('-');
            const yy = parseInt(parts[0],10);
            const mm = parseInt(parts[1],10);
            const dd = parseInt(parts[2],10);
            task.dueDate = new Date(yy, mm-1, dd).getTime();
            if(task.startTime != null){
              const dtOld = new Date(task.startTime);
              const h = dtOld.getHours();
              const minutes = dtOld.getMinutes();
              const dtNew = new Date(yy, mm-1, dd, h, minutes);
              task.startTime = dtNew.getTime();
            }
            markDirty();
            renderCalendar();
            // If the day view is open for this date, re-render it
            if(selectedDate && selectedDate === dateStr) renderDay(selectedDate);
            renderTasks(); renderKanban(); renderGrid(); renderNotesList();
          }
          cell.classList.remove('drag-over');
        });
        cell.dataset.date = dateStr;
        grid.appendChild(cell);
      }
      // Update month label
      const monthLabel = document.getElementById('calendarMonthLabel');
      const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
      monthLabel.textContent = monthNames[month] + ' ' + year;
      if(document.getElementById('daySidebarCalendar')){
        renderDaySidebarCalendar();
      }
    }

    function renderDaySidebarCalendar(){
      const grid = document.getElementById('daySidebarCalendar');
      const label = document.getElementById('daySidebarMonthLabel');
      if(!grid || !label) return;
      grid.innerHTML = '';
      const dayNames = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
      dayNames.forEach(name => {
        const div=document.createElement('div');
        div.className='day-of-week';
        div.textContent=name;
        grid.appendChild(div);
      });
      const year = daySidebarMonth.getFullYear();
      const month = daySidebarMonth.getMonth();
      const first = new Date(year, month, 1);
      const firstDay = first.getDay();
      const daysInMonth = new Date(year, month + 1, 0).getDate();
      const prevMonthDays = new Date(year, month, 0).getDate();
      const today = new Date(); today.setHours(0,0,0,0);
      for(let i=0;i<42;i++){
        const cell=document.createElement('div');
        cell.className='calendar-cell';
        let dateNum, cellMonth, cellYear;
        if(i < firstDay){
          dateNum = prevMonthDays - firstDay + 1 + i;
          cellMonth = month - 1;
          cellYear = year;
          if(cellMonth < 0){ cellMonth = 11; cellYear--; }
          cell.classList.add('out-month');
        } else if(i >= firstDay + daysInMonth){
          dateNum = i - (firstDay + daysInMonth) + 1;
          cellMonth = month + 1;
          cellYear = year;
          if(cellMonth > 11){ cellMonth = 0; cellYear++; }
          cell.classList.add('out-month');
        } else {
          dateNum = i - firstDay + 1;
          cellMonth = month;
          cellYear = year;
        }
        const cellDate = new Date(cellYear, cellMonth, dateNum);
        const dateStr = cellYear + '-' + zeroPad(cellMonth+1) + '-' + zeroPad(dateNum);
        if(isSameDate(cellDate, today)) cell.classList.add('today');
        if(selectedDate && selectedDate === dateStr) cell.classList.add('selected');
        const dateNumEl=document.createElement('div');
        dateNumEl.className='date-num';
        dateNumEl.textContent=dateNum;
        cell.appendChild(dateNumEl);
        cell.addEventListener('click', () => {
          selectedDate = dateStr;
          daySidebarMonth = new Date(cellYear, cellMonth, 1);
          calendarMonth = new Date(cellYear, cellMonth, 1);
          renderDay(selectedDate);
          renderCalendar();
        });
        grid.appendChild(cell);
      }
      const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
      label.textContent = monthNames[month] + ' ' + year;
    }

    // Change the calendar month by delta months (positive or negative)
    function changeMonth(delta){
      calendarMonth = new Date(calendarMonth.getFullYear(), calendarMonth.getMonth() + delta, 1);
      renderCalendar();
    }
    // Add navigation event listeners
    document.getElementById('prevMonthBtn').addEventListener('click', () => changeMonth(-1));
    document.getElementById('nextMonthBtn').addEventListener('click', () => changeMonth(1));
    const daySidebarPrevBtn = document.getElementById('daySidebarPrev');
    const daySidebarNextBtn = document.getElementById('daySidebarNext');
    if(daySidebarPrevBtn) daySidebarPrevBtn.addEventListener('click', () => {
      daySidebarMonth = new Date(daySidebarMonth.getFullYear(), daySidebarMonth.getMonth() - 1, 1);
      calendarMonth = new Date(daySidebarMonth.getFullYear(), daySidebarMonth.getMonth(), 1);
      renderCalendar();
    });
    if(daySidebarNextBtn) daySidebarNextBtn.addEventListener('click', () => {
      daySidebarMonth = new Date(daySidebarMonth.getFullYear(), daySidebarMonth.getMonth() + 1, 1);
      calendarMonth = new Date(daySidebarMonth.getFullYear(), daySidebarMonth.getMonth(), 1);
      renderCalendar();
    });

    // Utility function: check if two dates share the same year, month and day
    function isSameDate(d1, d2){
      return d1.getFullYear()===d2.getFullYear() && d1.getMonth()===d2.getMonth() && d1.getDate()===d2.getDate();
    }

    // Render the My Day view for a given date (YYYY-MM-DD)
    function renderDay(dateStr){
      selectedDate = dateStr;
      const dayLabel = document.getElementById('dayLabel');
      const unscheduled = document.getElementById('dayUnscheduled');
      const dayGrid = document.getElementById('dayGrid');
      if(!dayLabel || !unscheduled || !dayGrid) return;
      const slotInputs = [];
      // Parse date components
      const parts = dateStr.split('-');
      const yy = parseInt(parts[0],10);
      const mm = parseInt(parts[1],10);
      const dd = parseInt(parts[2],10);
      const dtBase = new Date(yy, mm-1, dd);
      const dayTimestamp = dtBase.getTime();
      daySidebarMonth = new Date(yy, mm-1, 1);
      renderDaySidebarCalendar();
      function refreshAfterStateChange(){
        markDirty();
        renderNotesList();
        refreshTaskShellViews();
      }
      function beginInlineEdit(taskId, host){
        if(!host || host.dataset.inlineEditing === '1') return;
        const task = state.tasks.find(t => t && t.id === taskId);
        if(!task) return;
        host.dataset.inlineEditing = '1';
        host.draggable = false;
        const input = document.createElement('input');
        input.type = 'text';
        input.value = task.title || '';
        input.className = 'day-slot-input';
        host.innerHTML = '';
        host.appendChild(input);
        let finished = false;
        const finish = (commit) => {
          if(finished) return;
          finished = true;
          if(commit){
            const updated = updateTaskTitleAndSync(taskId, input.value);
            if(updated){
              refreshAfterStateChange();
              return;
            }
          }
          renderDay(dateStr);
        };
        input.addEventListener('keydown', (ev) => {
          if(ev.key === 'Enter'){
            ev.preventDefault();
            finish(true);
          } else if(ev.key === 'Escape'){
            ev.preventDefault();
            finish(false);
          }
        });
        input.addEventListener('blur', () => finish(true));
        requestAnimationFrame(() => {
          input.focus();
          input.select();
        });
      }
      function setupDayTaskInteractions(taskEl, taskId){
        if(!taskEl) return;
        let clickTimer = null;
        taskEl.addEventListener('click', (ev) => {
          ev.stopPropagation();
          if(taskEl.dataset.inlineEditing === '1') return;
          if(ev.target && ev.target.tagName === 'INPUT') return;
          if(clickTimer) clearTimeout(clickTimer);
          clickTimer = window.setTimeout(() => {
            clickTimer = null;
            if(taskEl.dataset.preventModal === '1') return;
            openTaskModalForId(taskId);
          }, 170);
        });
        taskEl.addEventListener('dblclick', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          if(clickTimer) {
            clearTimeout(clickTimer);
            clickTimer = null;
          }
          openTaskModalForId(taskId);
        });
      }
      // Update header label
      dayLabel.textContent = dtBase.toLocaleDateString(undefined, { weekday:'long', year:'numeric', month:'long', day:'numeric' });
      // Clear containers
      unscheduled.innerHTML = '';
      dayGrid.innerHTML = '';
      // Gather tasks relevant to this day: tasks with dueDate matching dateStr or no dueDate
      const tasksForDay = state.tasks.filter(t => {
        if(!t.dueDate){
          // tasks with no due date are unscheduled and can be scheduled on this day
          return true;
        }
        const ddt = new Date(t.dueDate);
        return isSameDate(ddt, dtBase);
      });
      // Separate into unscheduled (no startTime or startTime outside 6-16:30) and scheduled
      const unsCandidates = [];
      const schedMap = {};
      tasksForDay.forEach(t => {
        const dueMatch = t.dueDate != null ? isSameDate(new Date(t.dueDate), dtBase) : false;
        const hasStart = Number.isFinite(t.startTime);
        if(hasStart){
          const st = new Date(t.startTime);
          const startMatchesDay = isSameDate(st, dtBase);
          const hour = st.getHours();
          const minute = st.getMinutes();
          const inWindow = hour >= 6 && (hour < 16 || (hour === 16 && minute <= 30));
          if(startMatchesDay && inWindow){
            const key = zeroPad(hour) + ':' + zeroPad(minute);
            if(!schedMap[key]) schedMap[key] = [];
            schedMap[key].push(t);
            return;
          }
          // Tasks with a start time that doesn't align with the visible window fall back to the unscheduled list.
          unsCandidates.push(t);
          return;
        }
        // No start time: treat as unscheduled. Only include if due date matches or dueDate is null.
        if(dueMatch || !t.dueDate) unsCandidates.push(t);
      });
      const slotAssignments = {};
      const primaryScheduledIds = new Set();
      Object.keys(schedMap).forEach(key => {
        const sorted = schedMap[key].slice().sort((a,b) => {
          if(a.priority !== b.priority) return a.priority - b.priority;
          return (a.createdAt||0) - (b.createdAt||0);
        });
        const primary = sorted.shift() || null;
        if(primary){
          slotAssignments[key] = primary;
          primaryScheduledIds.add(primary.id);
        }
        if(sorted.length){
          sorted.forEach(extra => unsCandidates.push(extra));
        }
      });
      function appendUnscheduledCard(t){
        const div = document.createElement('div');
        div.className = 'calendar-task';
        div.dataset.taskId = t.id;
        const titleLine=document.createElement('div');
        titleLine.className='calendar-task-title';
        applyTruncatedTitle(titleLine, t.title, { extraTooltip: t.details });
        div.appendChild(titleLine);
        if(t.dueDate && !isSameDate(new Date(t.dueDate), dtBase)){
          const meta=document.createElement('div');
          meta.className='calendar-task-meta';
          meta.textContent = 'Due ' + formatDate(t.dueDate);
          div.appendChild(meta);
        }
        if(t.details){
          const note=document.createElement('div');
          note.className='calendar-task-note';
          note.textContent=t.details;
          div.appendChild(note);
        }
        if(t.details){
          div.title = titleLine.dataset.fullTitle && titleLine.dataset.fullTitle !== t.details
            ? titleLine.dataset.fullTitle + '\n' + t.details
            : t.details;
        } else if(titleLine.getAttribute('title')){
          div.title = titleLine.getAttribute('title');
        }
        div.draggable = true;
        div.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', t.id);
        });
        setupDayTaskInteractions(div, t.id);
        unscheduled.appendChild(div);
      }
      // Render unscheduled tasks
      const seenUnscheduledIds = new Set();
      unsCandidates
        .filter(task => !primaryScheduledIds.has(task.id))
        .filter(task => {
          if(seenUnscheduledIds.has(task.id)) return false;
          seenUnscheduledIds.add(task.id);
          return true;
        })
        .forEach(t => appendUnscheduledCard(t));
      // Drag target: unscheduled container resets startTime
      unscheduled.addEventListener('dragover', (e) => {
        e.preventDefault();
        unscheduled.classList.add('drag-over');
      });
      unscheduled.addEventListener('dragleave', () => {
        unscheduled.classList.remove('drag-over');
      });
      unscheduled.addEventListener('drop', (e) => {
        e.preventDefault();
        const id = e.dataTransfer.getData('text/plain');
        const task = state.tasks.find(x => x.id === id);
        if(task){
          // assign this day if dueDate null or other day
          task.dueDate = dayTimestamp;
          task.startTime = null;
          refreshAfterStateChange();
        }
        unscheduled.classList.remove('drag-over');
      });
      // Build time slots 06:00 to 16:30 (30 min increments)
      const startHour = 6;
      const endHour = 17; // 5pm
      let h = startHour;
      let m = 0;
      while(true){
        const slot = document.createElement('div');
        slot.className = 'day-slot';
        // tag the slot with its time for easier event handlers
        slot.dataset.hour = h;
        slot.dataset.minute = m;
        const timeLabel = document.createElement('div');
        timeLabel.className = 'day-time';
        timeLabel.textContent = zeroPad(h) + ':' + zeroPad(m);
        slot.appendChild(timeLabel);
        const cell = document.createElement('div');
        cell.className = 'day-cell';
        const key = zeroPad(h) + ':' + zeroPad(m);
        const primaryTask = slotAssignments[key] || null;
        const slotTimestamp = new Date(yy, mm-1, dd, h, m).getTime();
        const originalTitle = primaryTask ? (primaryTask.title || '') : '';
        const quickInput = document.createElement('input');
        quickInput.type = 'text';
        quickInput.className = 'day-slot-input';
        quickInput.dataset.slotKey = key;
        quickInput.setAttribute('aria-label', `Add item at ${timeLabel.textContent}`);
        if(primaryTask){
          quickInput.value = originalTitle;
          quickInput.dataset.taskId = primaryTask.id;
          quickInput.placeholder = '';
          cell.dataset.taskId = primaryTask.id;
          cell.classList.add('has-value');
          cell.draggable = true;
          cell.addEventListener('dragstart', (e) => {
            if(document.activeElement === quickInput){
              e.preventDefault();
              return;
            }
            e.dataTransfer.setData('text/plain', primaryTask.id);
          });
          cell.addEventListener('dragend', () => {
            cell.classList.remove('drag-over');
          });
        } else {
          quickInput.placeholder = 'Add item…';
          delete cell.dataset.taskId;
          cell.classList.remove('has-value');
          cell.draggable = false;
        }
        const slotIndex = slotInputs.length;
        slotInputs.push({ input: quickInput, key });
        const moveFocusFrom = (fromIndex, delta, opts = {}) => {
          const targetIndex = fromIndex + delta;
          if(targetIndex < 0 || targetIndex >= slotInputs.length) return;
          const targetEntry = slotInputs[targetIndex];
          if(!targetEntry) return;
          const persist = !!opts.persist;
          if(persist){
            pendingDaySlotFocus = { key: targetEntry.key };
            setTimeout(() => {
              if(document.activeElement === targetEntry.input){
                pendingDaySlotFocus = null;
              }
            }, 150);
          } else {
            pendingDaySlotFocus = null;
          }
          targetEntry.input.focus();
          if(typeof targetEntry.input.select === 'function'){
            targetEntry.input.select();
          }
        };
        let hasCommittedNewTask = false;
        const commitSlotValue = (opts = {}) => {
          const nextKey = opts.nextKey || null;
          const text = quickInput.value.trim();
          const currentTaskId = quickInput.dataset.taskId;
          if(currentTaskId){
            if(!text){
              quickInput.value = originalTitle;
              return false;
            }
            const changed = updateTaskTitleAndSync(currentTaskId, text);
            if(changed){
              if(nextKey){
                pendingDaySlotFocus = { key: nextKey, select: true };
              }
              refreshAfterStateChange();
              return true;
            }
            if(nextKey && nextKey !== key){
              pendingDaySlotFocus = { key: nextKey, select: true };
            }
            return false;
          }
          if(!text) return false;
          if(hasCommittedNewTask) return false;
          if(nextKey){
            pendingDaySlotFocus = { key: nextKey, select: true };
          }
          const created = createManualTask(text, { dueDate: dayTimestamp, startTime: slotTimestamp });
          if(created){
            hasCommittedNewTask = true;
            refreshAfterStateChange();
            return true;
          }
          return false;
        };
        quickInput.addEventListener('keydown', (e) => {
          if(e.key === 'Enter'){
            e.preventDefault();
            const nextIdx = Math.min(slotInputs.length - 1, slotIndex + 1);
            const nextEntry = slotInputs[nextIdx];
            const nextKey = nextEntry ? nextEntry.key : null;
            const committed = commitSlotValue({ nextKey });
            if(!committed && nextEntry && nextIdx !== slotIndex){
              moveFocusFrom(slotIndex, nextIdx - slotIndex, { persist: false });
            }
          } else if(e.key === 'Tab'){
            e.preventDefault();
            const delta = e.shiftKey ? -1 : 1;
            const nextIdx = slotIndex + delta;
            const nextEntry = slotInputs[nextIdx];
            const nextKey = nextEntry ? nextEntry.key : null;
            const committed = commitSlotValue({ nextKey });
            if(!committed){
              const hasValue = quickInput.value.trim().length > 0 && !quickInput.dataset.taskId;
              moveFocusFrom(slotIndex, delta, { persist: hasValue });
            }
          } else if(e.key === 'ArrowDown'){
            e.preventDefault();
            const nextIdx = slotIndex + 1;
            const nextEntry = slotInputs[nextIdx];
            const nextKey = nextEntry ? nextEntry.key : null;
            const committed = commitSlotValue({ nextKey });
            if(!committed){
              const hasValue = quickInput.value.trim().length > 0 && !quickInput.dataset.taskId;
              moveFocusFrom(slotIndex, 1, { persist: hasValue });
            }
          } else if(e.key === 'ArrowUp'){
            e.preventDefault();
            const nextIdx = slotIndex - 1;
            const nextEntry = slotInputs[nextIdx];
            const nextKey = nextEntry ? nextEntry.key : null;
            const committed = commitSlotValue({ nextKey });
            if(!committed){
              const hasValue = quickInput.value.trim().length > 0 && !quickInput.dataset.taskId;
              moveFocusFrom(slotIndex, -1, { persist: hasValue });
            }
          } else if(e.key === 'Escape'){
            e.preventDefault();
            if(quickInput.dataset.taskId){
              quickInput.value = originalTitle;
            } else {
              quickInput.value = '';
            }
            quickInput.blur();
          }
        });
        quickInput.addEventListener('blur', () => {
          commitSlotValue();
          if(primaryTask){
            setTimeout(() => {
              if(cell.dataset.taskId){
                cell.draggable = true;
              }
            }, 100);
          }
        });
        quickInput.addEventListener('dragover', (e) => {
          e.preventDefault();
          cell.classList.add('drag-over');
        });
        quickInput.addEventListener('dragleave', () => {
          cell.classList.remove('drag-over');
        });
        quickInput.addEventListener('drop', (e) => {
          e.preventDefault();
          const id = e.dataTransfer.getData('text/plain');
          const task = state.tasks.find(x => x.id === id);
          if(task){
            task.dueDate = dayTimestamp;
            task.startTime = slotTimestamp;
            refreshAfterStateChange();
          }
          cell.classList.remove('drag-over');
        });
        cell.appendChild(quickInput);
        // Drag handlers for cell
        // handle drag-and-drop on the cell itself
        cell.addEventListener('dragover', (e) => {
          e.preventDefault();
          cell.classList.add('drag-over');
        });
        cell.addEventListener('dragleave', () => {
          cell.classList.remove('drag-over');
        });
        cell.addEventListener('drop', (e) => {
          e.preventDefault();
          const id = e.dataTransfer.getData('text/plain');
          const task = state.tasks.find(x => x.id === id);
          if(task){
            // update to this day's date and this slot's time
            task.dueDate = dayTimestamp;
            task.startTime = slotTimestamp;
            refreshAfterStateChange();
          }
          cell.classList.remove('drag-over');
        });

        // also treat the entire slot (row) as a drop target; this makes it easier to
        // drop tasks without having to target the narrow cell precisely. Use the dataset
        // hour/minute attributes defined on the slot to determine the drop time.
        slot.addEventListener('dragover', (e) => {
          e.preventDefault();
          cell.classList.add('drag-over');
        });
        slot.addEventListener('dragleave', () => {
          cell.classList.remove('drag-over');
        });
        slot.addEventListener('drop', (e) => {
          e.preventDefault();
          const id = e.dataTransfer.getData('text/plain');
          const task = state.tasks.find(x => x.id === id);
          if(task){
            const hh = parseInt(slot.dataset.hour, 10);
            const mm2 = parseInt(slot.dataset.minute, 10);
            task.dueDate = dayTimestamp;
            const dtNew = new Date(yy, mm-1, dd, hh, mm2);
            task.startTime = dtNew.getTime();
            refreshAfterStateChange();
          }
          cell.classList.remove('drag-over');
        });
        slot.appendChild(cell);
        dayGrid.appendChild(slot);
        // increment time
        if(h === endHour - 1 && m === 30) break;
        m += 30;
        if(m >= 60){ m = 0; h++; }
      }
      if(pendingDaySlotFocus && pendingDaySlotFocus.key){
        const target = dayGrid.querySelector(`.day-slot-input[data-slot-key="${pendingDaySlotFocus.key}"]`);
        if(target){
          target.focus();
          if(pendingDaySlotFocus.select !== false && typeof target.select === 'function'){
            target.select();
          }
        }
        pendingDaySlotFocus = null;
      }
    }

    // ---------- Context menu for item actions ----------
    const contextMenu = document.createElement('div');
    contextMenu.className = 'context-menu';
    const contextDeleteBtn = document.createElement('button');
    contextDeleteBtn.type = 'button';
    contextDeleteBtn.textContent = 'Delete';
    contextMenu.appendChild(contextDeleteBtn);
    document.body.appendChild(contextMenu);

    let contextTarget = null;

    function hideContextMenu(){
      contextMenu.style.display = 'none';
      contextTarget = null;
    }

    function showContextMenu(x, y){
      contextMenu.style.display = 'block';
      const rect = contextMenu.getBoundingClientRect();
      const padding = 8;
      let left = x;
      let top = y;
      if(left + rect.width > window.innerWidth - padding){
        left = Math.max(padding, window.innerWidth - rect.width - padding);
      }
      if(top + rect.height > window.innerHeight - padding){
        top = Math.max(padding, window.innerHeight - rect.height - padding);
      }
      contextMenu.style.left = left + 'px';
      contextMenu.style.top = top + 'px';
    }

    contextDeleteBtn.addEventListener('click', () => {
      if(!contextTarget) return;
      if(contextTarget.type === 'task'){
        deleteTaskById(contextTarget.id);
      } else if(contextTarget.type === 'note-line'){
        deleteNoteLine(contextTarget.index);
      }
      hideContextMenu();
    });

    document.addEventListener('click', hideContextMenu);
    window.addEventListener('resize', hideContextMenu);
    document.addEventListener('scroll', hideContextMenu, true);
    document.addEventListener('keydown', (e) => {
      if(e.key === 'Escape') hideContextMenu();
    });

    document.addEventListener('contextmenu', (e) => {
      const target = e.target.closest('[data-task-id],[data-note-line-index]');
      if(!target){
        hideContextMenu();
        return;
      }
      e.preventDefault();
      const taskId = target.dataset.taskId;
      if(taskId){
        const task = state.tasks.find(t => t && t.id === taskId);
        if(task){
          contextTarget = { type: 'task', id: task.id };
          showContextMenu(e.clientX, e.clientY);
          return;
        }
      }
      if(target.dataset.noteLineIndex != null){
        const idx = parseInt(target.dataset.noteLineIndex, 10);
        if(Number.isInteger(idx)){
          contextTarget = { type: 'note-line', index: idx };
          showContextMenu(e.clientX, e.clientY);
          return;
        }
      }
      hideContextMenu();
    });

    // ---------- Safe-area offsets (SharePoint mobile) ----------
    function parsePx(v,d){ const n=parseFloat(v); return Number.isFinite(n)? n:d; }
    function applySharePointCanvasOffsets(){ const wrap=document.querySelector('.wrap'); if(!wrap) return; const root=document.documentElement.style; if(!window.matchMedia('(max-width:600px)').matches){ root.setProperty('--sp-left-offset','0px'); root.setProperty('--sp-right-offset','0px'); return; } root.setProperty('--sp-left-offset','0px'); root.setProperty('--sp-right-offset','0px'); const rect=wrap.getBoundingClientRect(); const leftGap=Math.max(0, rect.left); const rightGap=Math.max(0, window.innerWidth - rect.right); const leftOffset=Math.max(0, leftGap - 1); const rightOffset=Math.max(0, rightGap - 1); root.setProperty('--sp-left-offset', leftOffset+'px'); root.setProperty('--sp-right-offset', rightOffset+'px'); }
    window.addEventListener('resize', applySharePointCanvasOffsets);
    document.addEventListener('readystatechange', ()=>{ if(document.readyState==='complete'){ applySharePointCanvasOffsets(); setTimeout(applySharePointCanvasOffsets, 150); setTimeout(applySharePointCanvasOffsets, 400); } });

    // ---------- Init ----------
    function renderAll(){ syncNotesToTasks(); renderNotes(); renderTagPalette(); refreshTaskShellViews(); }
    load(); initTheme(); buildSwatches(); renderAll(); setSaved(true); showView('notes');
  })();
  </script>
</body>
</html>
